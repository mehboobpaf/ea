//+------------------------------------------------------------------+
//|                                                                  |
//|            ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½  â€”  X A U / U S D  |
//|                                                                  |
//|                         âš”  GOLD MASTER SCALPING SYSTEM âš”        |
//|                                                                  |
//|----------------------------------------------------------------------------------|
//|                                                                                  |
//|   Â© 2025  Gold Master XAU Scalp Engine                                          |
//|   ğŸŒ Website     : https://www.yoursite                                           |
//|                                                                                  |
//|----------------------------------------------------------------------------------|
//|                                                                                  |
//|   ğŸ•‹ DU'A:                                                                        |
//|   "Ø§Ù„Ù„Ù‘Ù‡ÙÙ€Ù…Ù‘Ù Ù„Ø§ Ø³ÙÙ€Ù‡Ù’Ù„Ù Ø¥ÙÙ„Ø§Ù‘ Ù…ÙØ§ Ø¬ÙØ¹ÙÙ„Ù’Ù€ØªÙÙ‡Ù Ø³ÙÙ‡Ù€Ù„Ø§Ù‹                            |
//|    ÙˆÙØ£ÙÙ†Ù’Ù€ØªÙ ØªÙØ¬Ù’Ù€Ø¹ÙÙ„Ù Ø§Ù„Ù’Ø­ÙÙ€Ø²Ù’Ù†Ù Ø¥ÙØ°ÙØ§ Ø´ÙØ¦Ù’Ù€ØªÙ Ø³ÙÙ‡Ù€Ù„Ù‹Ø§"                          |
//|                                                                                  |
//|----------------------------------------------------------------------------------|
//|                                                                                  |
//|   ğŸš€ Designed & Engineered By : Mr. Mehboob Ali Leghari                          |
//|   ğŸŒŸ Title               : MQL5 Expert | Algo Architect                          |
//|   ğŸ† Experience          : 12+ Years Institutional Trading                       |
//|   ğŸ’¹ Market Expertise    : Forex | Crypto | Gold (XAU/USD) Scalping               |
//|   ğŸ§  Specialty            : Intelligent Grid | Martingale | AI Logic Systems     |
//|   ğŸ’» Profession           : EA Developer | Strategy Engineer                     |
//|                                                                                  |
//|----------------------------------------------------------------------------------|
//|                                                                                  |
//|   ğŸ“§ Email       : mehboobpaf@gmail.com                                           |
//|   ğŸ“± WhatsApp    : +92 314 9940155                                                |
//|                                                                                  |
//|==================================================================================|
#property copyright "Copyright 2025 ğŸŒŸ Gold Master XAU Scalper"
#property link      "https://www.yoursite ğŸŒ"
#property version   "3.16"
#property description "Ø§Ù„Ù„Ù‘Ù‡ÙÙ€Ù…Ù‘Ù Ù„Ø§ Ø³ÙÙ€Ù‡Ù’Ù„Ù Ø¥ÙÙ„Ø§Ù‘ Ù…Ø§ Ø¬ÙØ¹ÙÙ„Ù€ØªÙÙ‡Ù Ø³ÙÙ‡Ù€Ù„Ø§Ù‹\n*EA Design By Mr. Mehboob Ali Leghari, MQL5 Master*\n\n=== Expert Advisor Creator ===\nMehboob Ali Leghari\nProfessional Algo Trader | 12 Years of Trading Experience\nSpecializing in Forex, Crypto, and XAU/USD Scalping\nMQL5 Expert | EA Developer | Strategy Creator\nContact: mehboobpaf@gmail.com\nWhatsApp: +923149940155 ğŸŒŸ"

//------------------------------------------------------------------
// Include Libraries for Trading, Chart Objects & Logging ğŸŒŸ
#include <Trade/Trade.mqh>
#include <ChartObjects/ChartObjectsTxtControls.mqh>
#include <Arrays/ArrayObj.mqh>

// Trading Class ğŸŒŸ
CTrade trade;

//------------------------------------------------------------------
// ENUMS: Martingale & StopLoss Modes ğŸ‰ğŸ€
enum ENUM_MARTINGALE_TYPE { MARTIN_FIXED_STEP = 0, MARTIN_MULTIPLIER = 1 };
enum ENUM_SL_MODE { SL_MODE_NONE = 0, SL_MODE_POINTS = 1 };

//========================= ENUM FOR TRUE/FALSE DROP-DOWN =====================
enum ENUM_BOOL
{
   FALSE = 0,
   TRUE  = 1
};

//+------------------------------------------------------------------+
//| ğŸ› TRADING MODE PRESET SYSTEM                                  |
//+------------------------------------------------------------------+
enum ENUM_TRADING_MODE
{
   MODE_DEFAULT = 0,      // ğŸ§™ EA Default behavior
   MODE_BUY_ONLY,         // ğŸŸ¢ Buy orders only
   MODE_SELL_ONLY,        // ğŸ”´ Sell orders only  
   MODE_MANUAL_ONLY,      // âœ‹ Manual trading only
   MODE_DISABLE_ALL,      // ğŸš« Safety mode - no trading
   MODE_CUSTOM            // âš™ï¸ User manual control
};

//+------------------------------------------------------------------+
//| ğŸ› PROFIT SETTING PRESET SYSTEM                                |
//+------------------------------------------------------------------+
enum ENUM_PROFIT_SETTING
{
   MODE_MY_SAFE = 0,         // ğŸ›¡ Very Low Profit but Very Safe  (User Wish - Default)
   MODE_SUPER_SAFE,          // ğŸ§Š Ultra Safe â€“ Minimal Drawdown
   MODE_MODERATE_SAFE,       // âš–ï¸ Moderate Profit â€“ Balanced Safety
   MODE_RISKY_PROFIT         // ğŸ”¥ High Profit â€“ Risky but Still Safe
};

//==================================================================
//==================== ğŸ› ğŸŸ¢ BASIC PARAMETERS ğŸŸ¢ğŸ›  ====================
// Core trading controls, spread & time filters
//==================================================================
input group "====== ğŸ› ğŸŸ¢ BASIC PARAMETERS ğŸŸ¢ğŸ›  =================";

input ENUM_TRADING_MODE TradingMode   = MODE_DEFAULT;    // ğŸ› MASTER CONTROL
input string           sOrdComm       = "EA ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½";// ğŸ’¬ EA COMMENT
input int              MaxSpred       = 160;             // ğŸ“Š MAX SPREAD
input string           Start_Hour     = "00:00";         // â± START TIME
input string           End_Hour       = "23:59";         // â± END TIME
input ulong            Magic          = 786;             // ğŸ§™ MAGIC NUMBER

//==================================================================
//==================== ğŸ“ˆâš¡ STRATEGY SETTINGS âš¡ğŸ“ˆ ====================
// Lot sizing, SL/TP & trade management
//==================================================================
input group "======= ğŸ“ˆâš¡ STRATEGY SETTINGS âš¡ğŸ“ˆ =================";

input double     Lot_Init_              = 0.01;   // ğŸ¯ INITIAL LOT
input ENUM_BOOL  EnableFirstLotTP       = TRUE;   // âœ… FIRST LOT TP
input int        FirstLotTPPoints       = 1000;   // ğŸ”¹ FIRST TP POINTS
input ENUM_PROFIT_SETTING ProfitSetting = MODE_MY_SAFE;  // ğŸ“Š PROFIT SETTING PRESET
input ENUM_SL_MODE SL_Mode              = SL_MODE_NONE; // ğŸ›¡ STOP LOSS MODE
input int        SL_                    = 0;      // âš” STOP LOSS POINTS
input ENUM_BOOL  EnableVirtualStopLoss  = FALSE;  // ğŸ‘» VIRTUAL STOP LOSS
input double     StopLossPoints         = 5000;   // ğŸ›‘ SL POINT VALUE
input ENUM_BOOL  Autolot_               = FALSE;  // âš– AUTO LOT ENABLE
input int        Autolotsize_           = 1000;   // ğŸ“ Auto Lot CALC FACTOR

//==================================================================
//==================== â™Ÿï¸ğŸ”¥ MARTINGALE SYSTEM ğŸ”¥â™Ÿï¸ ====================
// Aggressive multiplier system
//==================================================================
input group "======= â™Ÿï¸ğŸ”¥ MARTINGALE SYSTEM ğŸ”¥â™Ÿ =================";

input ENUM_MARTINGALE_TYPE MartingaleType        = MARTIN_MULTIPLIER; // ğŸ”º SELECT MODE TYPE
input double              MultiplierFactor       = 1.5;               // âœ– LOT MULTIPLIER
input double              FixedStepLots          = 0.02;              // â• LOT STEP FIX MARTING:
input int                 MaxConcurrentOrders    = 25;                // ğŸ”¢ MAX TRADES 
input double              MaxLot_                = 5.5;               // ğŸ‹ MAX LOT LIMIT

//==================================================================
//==================== ğŸ“ŠğŸ’ GRID STRATEGY SETTINGS ğŸ’ğŸ“Š =================
// Grid-based trend management
//==================================================================
input group "======= ğŸ“ŠğŸ’ GRID STRATEGY SETTINGS ğŸ’ğŸ“Š =================";

input ENUM_TIMEFRAMES Grid_MA_Timeframe = PERIOD_CURRENT; // â± MA TIMEFRAME
input int             Grid_MA_Period    = 200;            // ğŸ“ MA PERIOD
input ENUM_MA_METHOD  Grid_MA_Method    = MODE_SMA;       // ğŸ”¹ MA METHOD
input ENUM_APPLIED_PRICE Grid_MA_Price  = PRICE_CLOSE;    // ğŸ’µ MA PRICE TYPE
input int             Grid_Step         = 180;            // â†• GRID STEP
input int             Max_Grid_Orders   = 25;             // ğŸ”¢ MAX GRID ORDERS
input int             MaxOrdersBuy      = 25;             // ğŸŸ¢ MAX BUY COUNT
input int             MaxOrdersSell     = 25;             // ğŸ”´ MAX SELL COUNT

//==================================================================
//==================== ğŸ›ğŸŒŸ STOCHASTIC SETTINGS ğŸŒŸğŸ› ===================
// Stochastic oscillator
//==================================================================
input group "======== ğŸ›ğŸŒŸ STOCHASTIC SETTINGS ğŸŒŸğŸ› =================";

input ENUM_BOOL      Use_Stoh       = FALSE;          // ğŸ“Š ENABLE STOCH
input ENUM_TIMEFRAMES TF_Stoh       = PERIOD_CURRENT; // â± STOCH TIMEFRAME
input int            Up_Level       = 83;             // ğŸ”º OVERBOUGHT
input int            Down_Level     = 18;             // ğŸ”» OVERSOLD
input int            KPeriod        = 5;              // ğŸ”¹ K PERIOD
input int            DPeriod        = 3;              // ğŸ”¹ D PERIOD
input int            Slowing        = 3;              // ğŸ¢ SLOWING
input bool           UseStochasticMAConfirm = false;  // âœ… MA CONFIRM

//==================================================================
//==================== ğŸ’°ğŸ”¥ PROFIT / LOSS EXIT ğŸ”¥ğŸ’° ===================
// Automated target system
//==================================================================
input group "===ğŸ“Œ TARGET BASED PROFIT & LOSS EXIT===";

input ENUM_BOOL EnableProfitLossExit = FALSE; // âœ… ENABLE SYSTEM
input double    ProfitTarget         = 500;   // ğŸ’µ PROFIT TARGET
input double    LossLimit            = -300;  // âŒ LOSS LIMIT
input ENUM_BOOL CloseOnTarget        = TRUE;  // ğŸ”’ AUTO CLOSE

//==================================================================
//==================== ğŸ–¥ğŸ¨ CHART VISUAL SETTINGS ğŸ¨ğŸ–¥ =================
// Panel & logging controls
//==================================================================
input group "======== ğŸ–¥ğŸ¨ CHART VISUAL SETTINGS ğŸ¨ğŸ–¥ =================";

input ENUM_BOOL EnableInfoPanel         = TRUE;  // ğŸ“ PANEL ON / OFF
input ENUM_BOOL EnableCandleColoring    = TRUE;  // ğŸ•¯ COLOR CANDLES
input ENUM_BOOL EnableProfitLossDisplay = FALSE; // ğŸ“ˆ SHOW PNL TAG
input bool      EnableEnhancedLogging   = true;  // ğŸ“œ SMART LOGGING

//+------------------------------------------------------------------+
//|                 ğŸ’– INTERNAL CHART VISUAL CONSTANTS ğŸ’–            |
//|                   Beautified & Romantic Edition                 |
//+------------------------------------------------------------------+

//------------------------------------------------------------------
//                    ğŸŒˆ GENERAL CHART SETTINGS ğŸŒˆ
//------------------------------------------------------------------
const bool EnableChartVisuals   = true;     // ğŸŒŸ Enable all chart visuals
const bool ShowTradeLevels      = true;     // ğŸ“ˆ Show trade entry/exit levels
const bool ShowBidAskLines      = true;     // ğŸ’Œ Show bid/ask lines
const bool EnableAutoScroll     = true;     // ğŸŒŠ Auto-scroll chart with price
const bool KeepChartStable      = true;     // ğŸ›¡ Keep chart stable during updates
const int       PanelCorner             = 0;          // ğŸ”² CORNER
const int       PanelX                  = 14;         // â¡ X
const int       PanelY                  = 30;         // â¬‡ Y
const color     Chart_Background        = clrBlack;   // ğŸ¨ BG
const color     Chart_Foreground        = clrWhite;   // ğŸ¨ FG
const int    LogUpdateFrequency = 300;        // â± Status update frequency (seconds)

//------------------------------------------------------------------
//           ğŸ›¡ INTERNAL FIXED MARTINGALE DISTANCE CONSTANTS ğŸ›¡
//------------------------------------------------------------------
const int    Fix_Distance             = 0;   // ğŸ“Œ FIX DISTANCE (Constant)
const int    Order_dinamic_distance   = 0;   // ğŸ“ˆ DYNAMIC GAP (Constant)
const int    Dynamic_distance_start   = 0;   // ğŸš€ DYNAMIC START (Constant)
const double Distance_multiplier      = 0.0; // âœ¨ GAP MULTIPLIER (Constant)

//------------------------------------------------------------------
//                    ğŸ’• One Bar Trading Rules ğŸ’•
//------------------------------------------------------------------
const bool      AllowMultipleSeriesPerBar = FALSE; // ğŸ”„ MULTIPLE SERIES
const int            MinBarChangeChecks         = 3;    // âœ… MIN TICKS
const ENUM_TIMEFRAMES OneBarTimeframe = PERIOD_CURRENT;  // Constant, NOT shown in inputs

//------------------------------------------------------------------
//                    ğŸ’• PROFIT & LOSS LINES ğŸ’•
//------------------------------------------------------------------
const bool   ShowTPLine          = true;    // ğŸ’š Show Take Profit line
const color  BreakEvenLineColor  = clrGold; // âœ¨ Break-even line color
const int    BreakEvenLineWidth  = 1;       // ğŸ–Œ Line width for break-even
const color  StopLossLineColor   = clrRed;  // â¤ï¸ Stop Loss line color

const bool   EnableDebugLog      = true;    // ğŸ“ Enable debug messages

const color  BidLineColor        = clrRed;  // ğŸ”´ Bid line
const color  AskLineColor        = clrLime; // ğŸ’š Ask line
const color  TPLineColor         = clrLime; // ğŸ’ TP line

//------------------------------------------------------------------
//                    ğŸ•¯ CANDLE COLORS & DYNAMICS ğŸ•¯
//------------------------------------------------------------------
const color Candle_Bull_Color    = clrGreen; // ğŸŸ¢ Bull candle
const color Candle_Bear_Color    = clrRed;   // ğŸ”´ Bear candle
const bool  DynamicCandleColors  = true;     // ğŸ¨ Enable dynamic candle coloring
const int   ColorUpdateFrequency = 5;        // â± Update every 5 ticks

//------------------------------------------------------------------
//                     ğŸ–Œ TEXT & PROFIT DISPLAY ğŸ–Œ
//------------------------------------------------------------------
const color   ProfitColor = clrTurquoise; // ğŸ’– Profit text color
const int     FontSize    = 8;            // ğŸ”¤ Font size for display
const string  FontFace    = "Arial";      // ğŸ”  Font type for chart text
const int     TextOffset  = 25;           // ğŸ“ Distance from candle to text

//------------------------------------------------------------------
//                ğŸ›¡ SAFE OVERLAP SYSTEM SETTINGS ğŸ›¡
//------------------------------------------------------------------
const bool   EnableSafeOverlap       = true;      // ACTIVE
int    OverlapPointsDifference = 25;        // Points difference for overlap
double OverlapMinNetProfit     = 3.5;       // Minimum net profit for overlap
int    OverlapCheckFrequency   = 1;         // Check frequency (seconds)
int    MinuteStop              = 0;         // Minute stop
bool   CloseOldestFirst        = TRUE;      // Close oldest first
bool   RequireProfitForNextTrade = true;    // Require profit for next trade
int    MinProfitDistance       = 10;        // Minimum profit distance
// --- Emergency safety ---
const double MaxAllowedUnrealizedLossUSD = 10000.0;
const double MaxExposureLots          = 1000.05;


//------------------------------------------------------------------
//                 ğŸ’ OPTIMIZED BREAK-EVEN SETTINGS ğŸ’
//------------------------------------------------------------------
const bool   EnableBreakEven        = true;  

// -----------------------------------------------
// âœ” MATCHED TO OVERLAP SYSTEM LOGIC (GOLD â€“ M1)
// -----------------------------------------------
const double BreakEvenLevel         = 80;     // â­ BEST MATCH VALUE
// Explanation:
// OverlapPointsDifference=25
// MinProfitDistance=10
// Gold M1 volatility avg = 120â€“180 points swings
// â†’ Ideal BE trigger = 3Ã— overlap step â‰ˆ 75 â†’ round to 80

const double BreakEvenClosePercent  = 60.0;   // â­ SAFE & REALISTIC
// Explanation:
// 70% too aggressive for gold spikes.
// 60% gives partial profit lock without early cut.

const double BasketTarget           = 35;      // â­ PERFECT ALIGNMENT
// Explanation:
// OverlapMinNetProfit=3.5 per cycle
// Typical 10â€“12 cycle basket â†’ $30â€“40
// â†’ $35 is **mathematically aligned** to your overlap model

//==================================================================
//==================== ğŸ•¯ ONE TRADE PER CANDLE SYSTEM ğŸ•¯ ==============
// Guaranteed one trade per candle
//===================================================================
// ğŸš« These are no longer user-editable â€” now internal constants  
const bool            EnableOneTradePerCandle = true;           // ğŸ¯ ENABLE MODE
const ENUM_TIMEFRAMES TradeTimeframe          = PERIOD_CURRENT; // â± TRADE TF
const bool            ForceTradeEveryCandle   = true;           // ğŸ”¥ FORCE ENTRY

//+------------------------------------------------------------------+
//| ğŸ¯ BROKER DIGITS & POINT NORMALIZATION SYSTEM                  |
//| Critical fix for 3-digit brokers and profit calculation bugs   |
//+------------------------------------------------------------------+

// Global variables for broker digit compatibility
int      g_digits = 0;                    // ğŸ¯ Broker digits
double   g_point = 0.0;                   // ğŸ“ Normalized point value
double   g_pipValue = 0.0;                // ğŸ’° Pip value in account currency
double   g_tickValue = 0.0;               // âš¡ Tick value
double   g_tickSize = 0.0;                // ğŸ“ Tick size
double   g_contractSize = 0.0;            // ğŸ“¦ Contract size

//+------------------------------------------------------------------+
//| ğŸ¯ INITIALIZE BROKER SETTINGS - CRITICAL FIX                   |
//+------------------------------------------------------------------+
void InitializeBrokerSettings()
{
    // Get broker-native values
    g_digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
    g_point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    g_tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    g_tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    g_contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
    
    // Correct pip value calculation for different digit brokers
    if(g_digits == 3 || g_digits == 5)
        g_pipValue = g_point * 10;  // For 3-digit (XAUUSD) and 5-digit brokers
    else
        g_pipValue = g_point;       // For 2-digit and 4-digit brokers
    
    PrintFormat("âœ… BROKER SETTINGS: Digits=%d, Point=%.5f, TickValue=%.5f, PipValue=%.5f", 
                g_digits, g_point, g_tickValue, g_pipValue);
    PrintFormat("âœ… CONTRACT SIZE: %.2f, Tick Size: %.5f", g_contractSize, g_tickSize);
}

//+------------------------------------------------------------------+
//| ğŸ¯ POINTS TO PRICE CONVERSION - FIXED                          |
//+------------------------------------------------------------------+
double PointsToPrice(double points)
{
    return points * g_pipValue;
}

//+------------------------------------------------------------------+
//| ğŸ¯ PRICE TO POINTS CONVERSION - FIXED                          |
//+------------------------------------------------------------------+
double PriceToPoints(double priceDiff)
{
    if(g_pipValue > 0)
        return priceDiff / g_pipValue;
    return priceDiff / g_point;
}

//+------------------------------------------------------------------+
//| ğŸ¯ CORRECT PROFIT CALCULATION - USES BROKER NATIVE VALUES      |
//+------------------------------------------------------------------+
double CalculateProfitInDollarsCorrect(double priceDiff, double volume)
{
    // Use broker's native tick value - this is the CORRECT way
    if(g_tickSize > 0 && g_tickValue > 0)
    {
        double ticks = priceDiff / g_tickSize;
        return ticks * g_tickValue * volume;
    }
    
    // Fallback to point-based calculation using correct pip value
    double points = PriceToPoints(priceDiff);
    double profitPerPoint = g_tickValue * volume;
    
    return points * profitPerPoint;
}

//+------------------------------------------------------------------+
//| ğŸ¯ GET POSITION PROFIT IN POINTS - FIXED (SINGLE DEFINITION)   |
//+------------------------------------------------------------------+
double GetPositionProfitPoints(ulong ticket, double currentPrice)
{
    if(!PositionSelectByTicket(ticket)) return 0.0;

    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

    double priceDiff = 0.0;
    if(type == POSITION_TYPE_BUY)
        priceDiff = (currentPrice - openPrice);
    else
        priceDiff = (openPrice - currentPrice);

    // Convert price difference to points using correct pip value
    return PriceToPoints(priceDiff);
}

//+------------------------------------------------------------------+
//| ğŸ¯ STRATEGY TESTER DETECTION & ADJUSTMENT                      |
//+------------------------------------------------------------------+

bool IsStrategyTester()
{
    return (MQLInfoInteger(MQL_TESTER) != 0);
}

void AdjustForTesterEnvironment()
{
    if(IsStrategyTester())
    {
        Print("ğŸ”§ Running in Strategy Tester - applying environment adjustments");
        
        // Force symbol selection and refresh rates
        SymbolSelect(_Symbol, true);
        Sleep(100);
        
        // Re-initialize broker settings in tester
        InitializeBrokerSettings();
    }
}

/* ===========================================================
   ğŸŒğŸ’™ GLOBAL VARIABLES
   Core runtime storage for EA state, history tracking,
   trading logic flags, visual updates & internal operations.
   =========================================================== */

// âœ… INTERNAL TRADING CONTROL VARIABLES (Replaced input booleans)
bool NewCycle_             = true;    // ğŸ”„ NEW CYCLE
bool Flag_Trade_Buy_       = true;    // ğŸŸ¢ BUY
bool Flag_Trade_Sell_      = true;    // ğŸ”´ SELL  
bool ManualHandOrder       = true;    // âœ‹ MANUAL ORDERS
bool OnlyManualTrading     = false;   // ğŸ“ MANUAL ONLY
bool GridSingleTradePerBar = true;    // 1 TRADE PER BAR

// ğŸ•¯ Enhanced One Trade Per Candle Variables
datetime lastCandleTraded = 0;
bool candleTradeTaken = false;
int consecutiveMissedCandles = 0;
datetime lastForcedTradeTime = 0;

//------------------------------------------------------------------
// ğŸ”¹ Lot & Trading State ğŸ’–
double      minLot, maxLot, lotStep;                 // ğŸ¯ Lot sizing control
datetime    lastTradeTime           = 0;             // â± Timestamp of last trade
double      lastBuyPrice            = 0, 
            lastSellPrice           = 0;             // ğŸ’¹ Last buy/sell prices
double      initialBalance;                          // ğŸ’° Initial account balance

//------------------------------------------------------------------
// ğŸ”¹ Martingale / Sequence Tracking ğŸ”¥
int         buyMartingaleSequence   = 0, 
            sellMartingaleSequence  = 0;             // ğŸ”º Current martingale levels
double      lastBuyLot              = 0.0, 
            lastSellLot             = 0.0;           // ğŸ’ Last executed lot sizes
datetime    lastBuyTradeTime        = 0, 
            lastSellTradeTime       = 0;             // ğŸ•’ Last trade timestamps
int         buyMartingaleLevel      = 0, 
            sellMartingaleLevel     = 0;             // ğŸŒ¸ Martingale multiplier levels

//------------------------------------------------------------------
// ğŸ”¹ Series Direction Control ğŸ’
ENUM_POSITION_TYPE currentSeriesDirection = WRONG_VALUE; // â¡ Current series direction
bool        seriesActive           = false;             // â¤ï¸ Series active flag

//------------------------------------------------------------------
// ğŸ”¹ Candle Timing & New-Bar Detection ğŸ•¯
datetime    currentCandleTime      = 0;                 // â± Current candle time
bool        newCandleFlag          = false;             // ğŸŒŸ New candle detected

//------------------------------------------------------------------
// ğŸ”¹ Indicator Handles ğŸ›
int         hStochastic            = INVALID_HANDLE;   // ğŸ“Š Stochastic handle
int         hGridMA                = INVALID_HANDLE;   // ğŸ“ˆ Grid MA handle

//------------------------------------------------------------------
// ğŸ”¹ EA Session & Startup ğŸŒ
datetime    startTime              = 0;                // ğŸ EA start time
ulong       firstBuyLotTicket      = 0, 
            firstSellLotTicket     = 0;                // ğŸŸ Tickets for first buy/sell lots

//------------------------------------------------------------------
// ğŸ”¹ Profit Tracking ğŸ’µ
double      cumulativeRealizedProfit = 0.0;            // ğŸ’– Total realized profit

//------------------------------------------------------------------
// ğŸ”¹ Virtual SL / Break-Even ğŸ›¡
double      virtualStopLossLevel   = 0.0;             // ğŸ›‘ Virtual stop loss
bool        stopLossHit            = false;           // âš” Stop-loss hit flag
double      breakEvenPrice         = 0.0;             // ğŸ’› Break-even price

//------------------------------------------------------------------
// ğŸ”¹ Scheduled Update Timers â±
datetime    lastPanelUpdate        = 0;                // ğŸ“Š Last info panel update
datetime    lastOverlapCheck       = 0;                // ğŸ”„ Last safe overlap check
datetime    lastTradeCheck         = 0;                // ğŸ•’ Last trade evaluation

//------------------------------------------------------------------
// ğŸ”¹ Cached Values (Optimization) ğŸ’¡
int         cachedBuyPositions     = -1, 
            cachedSellPositions    = -1;               // ğŸ’ Cached open positions
double      cachedEquity           = 0, 
            cachedBalance          = 0;                // ğŸ’° Cached account values
bool        positionsDirty         = true;             // ğŸ“ Flag for position changes

//------------------------------------------------------------------
// ğŸ”¹ Equity Controls ğŸ’–
double      equityBaseLevel        = 0.0;             // ğŸ’µ Base equity level
bool        equityStopTriggered    = false;           // ğŸš« Stop due to equity breach
bool        profitTargetReached    = false;           // ğŸ† Profit target reached

//------------------------------------------------------------------
// ğŸ”¹  Display Cache ğŸ–¥
string      lastPanelTexts[20];                        // ğŸ“œ Cached panel texts
datetime    lastDataUpdate         = 0;                // â± Last data refresh

//------------------------------------------------------------------
// ğŸ”¹ Cached Volumes & Profit ğŸ“Š
double      cachedBuyVolume        = 0, 
            cachedSellVolume       = 0;                // ğŸ”¹ Volume caching
double      cachedBuyProfit        = 0, 
            cachedSellProfit       = 0;                // ğŸ’š Profit caching

//------------------------------------------------------------------
// ğŸ”¹ Chart & Visual Systems ğŸ¨
datetime    lastChartVisualUpdate  = 0;                // ğŸ–Œ Last visual update
bool        chartInitialized       = false;           // ğŸŒŸ Chart initialized

//------------------------------------------------------------------
// ğŸ”¹ Initial Base Lot Storage ğŸ¯
double      initialBuyBaseLot      = 0.0, 
            initialSellBaseLot     = 0.0;              // ğŸ’– Initial base lots

//------------------------------------------------------------------
// ğŸ”¹ Processing Lock ğŸ”’
bool        isProcessing           = false;           // ğŸ›¡ Lock for safe processing

/* ===========================================================
   ğŸ“ŠğŸŸ§ ENHANCED ONE-BAR TRADING VARIABLES ğŸ•¯
   Controls for advanced per-bar execution logic.
   =========================================================== */
datetime    currentBarTime         = 0;                // â± Current bar timestamp
int         barChangeCounter       = 0;                // ğŸ”„ Number of bar changes detected
bool        newBarConfirmed        = false;            // ğŸ’Œ New bar confirmed
double      lastBarOpenPrice       = 0.0;              // ğŸ•Š Last bar open price
datetime    lastTradeBarTime       = 0;                // â³ Last trade on bar timestamp

/* ===========================================================
   ğŸŸ¡âš¡ ENHANCED BREAK-EVEN VARIABLES
   Full storage for tracking break-even behavior.
   =========================================================== */

bool        breakEvenActive = false;
double      breakEvenTriggerPrice = 0.0;
double      breakEvenBasePrice = 0.0;
int         breakEvenPositionsClosed = 0;

/* ===========================================================
   ğŸ¯ğŸŸ£ PROFESSIONAL LAST ACTION DISPLAY
   Text shown on chart when trades open/close.
   =========================================================== */

string      lastActionText = "";
datetime    lastActionTime = 0;
color       lastActionColor = clrWhite;
double      lastActionProfit = 0.0;
bool        lastActionVisible = false;
bool        firstActionShown = false;

/* ===========================================================
   ğŸ•¯ğŸ”´ CANDLE COLORING VARIABLES
   Used for dynamic candle recoloring (bull/bear).
   =========================================================== */

datetime    lastColorUpdate = 0;
color       currentBullColor = clrGreen;
color       currentBearColor = clrRed;
bool        colorsInitialized = false;

/* ===========================================================
   ğŸ’°ğŸŸ¢ PROFIT / LOSS EXIT VARIABLES
   Control daily targets, limits & flickering alerts.
   =========================================================== */

bool        profitTargetHit = false;
bool        lossLimitHit = false;
bool        tradingHalted = false;

datetime    lastProfitLossCheck = 0;
datetime    lastFlickerUpdate   = 0;

color       profitMessageColor = clrLime;
color       lossMessageColor   = clrRed;

bool        flickerState = false;
double      dailyStartBalance = 0;
datetime    lastDailyReset = 0;

/* ===========================================================
   ğŸ”ğŸŸ¤ SAFE OVERLAP SYSTEM VARIABLES
   Secure multi-order closure logic.
   =========================================================== */

int         overlapClosuresCount = 0;
double      totalOverlapProfit = 0.0;

/* ===========================================================
   ğŸ’¬âšª PROFIT/LOSS DISPLAY STRUCTURE
   Stores closed profitable trades for chart display.
   =========================================================== */

struct ClosedTradeInfo
{
   ulong              ticket;
   datetime           closeTime;
   double             profit;
   double             closePrice;
   ENUM_POSITION_TYPE type;
};

// Storage array for closed trades
ClosedTradeInfo  closedTradesArray[];
int              closedTradesCount = 0;
datetime         sessionStartTime = 0;   // Tracks EA session start

//+------------------------------------------------------------------+
//| ğŸš¨ GLOBAL TRADING SAFETY CHECK                                 |
//+------------------------------------------------------------------+
bool IsTradingPermitted()
{
    // ğŸš¨ Check all halt conditions
    if(tradingHalted) {
        Print("ğŸš¨ GLOBAL BLOCK: Trading halted");
        return false;
    }
    
    if(profitTargetHit) {
        Print("ğŸš¨ GLOBAL BLOCK: Profit target hit");
        return false;
    }
    
    if(lossLimitHit) {
        Print("ğŸš¨ GLOBAL BLOCK: Loss limit hit");
        return false;
    }
    
    if(stopLossHit) {
        Print("ğŸš¨ GLOBAL BLOCK: Stop loss hit");
        return false;
    }
    
    if(OnlyManualTrading) {
        Print("ğŸš¨ GLOBAL BLOCK: Manual trading only mode");
        return false;
    }
    
    if(!IsTradingAllowed()) {
        Print("ğŸš¨ GLOBAL BLOCK: Trading not allowed (time/spread)");
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| ğŸ¯ Calculate Next Martingale Lot                                    |
//+------------------------------------------------------------------+
double CalculateMartingaleLotSize(ENUM_POSITION_TYPE type)
{
    if(OnlyManualTrading) return 0;

    // ğŸ”¹ Determine current sequence number based on open positions
    int seqNum = 0;

    // ğŸ”¹ Count only positions in loss for martingale
    int totalPositions = PositionsTotal();
    for(int i = 0; i < totalPositions; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;

        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if(posType != type) continue;

        double profit = PositionGetDouble(POSITION_PROFIT);
        if(profit <= 0) seqNum++; // count losing positions only
    }

    // ğŸ”¹ First trade or no losing positions â†’ use base lot
    if(seqNum == 0)
        return GetBaseLotSize();

    // ğŸ”¹ Get base lot for type
    double baseLot = (type == POSITION_TYPE_BUY) ? initialBuyBaseLot : initialSellBaseLot;
    if(baseLot <= 0) baseLot = GetBaseLotSize();

    // ğŸ”¹ Calculate lot based on sequence number
    double calculatedLot = 0;
    if(MartingaleType == MARTIN_FIXED_STEP)
        calculatedLot = baseLot + (FixedStepLots * seqNum);
    else // MARTIN_MULTIPLIER
        calculatedLot = baseLot * MathPow(MultiplierFactor, seqNum);

    // ğŸ”¹ Round to broker lot step
    calculatedLot = MathRound(calculatedLot / lotStep) * lotStep;

    // ğŸ”¹ Apply min/max limits
    calculatedLot = MathMax(MathMin(calculatedLot, MathMin(MaxLot_, maxLot)), minLot);

    PrintFormat("Martingale CALC: Type=%s, Seq=%d, Base=%.4f, Result=%.4f",
                EnumToString(type), seqNum, baseLot, calculatedLot);

    return NormalizeDouble(calculatedLot, 2);
}


//+------------------------------------------------------------------+
//| ğŸ¯ GET ALL LOT SIZES FOR DEBUGGING                              |
//+------------------------------------------------------------------+
void GetCurrentLotSequence(ENUM_POSITION_TYPE type, double &lots[])
{
    ArrayResize(lots, 0);
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if(posType != type) continue;
        
        double lot = PositionGetDouble(POSITION_VOLUME);
        int size = ArraySize(lots);
        ArrayResize(lots, size + 1);
        lots[size] = lot;
    }
    
    // Sort in ascending order
    ArraySort(lots);
    
    // Print for debugging
    if(ArraySize(lots) > 0)
    {
        string lotStr = "";
        for(int i = 0; i < ArraySize(lots); i++)
            lotStr += DoubleToString(lots[i], 3) + (i < ArraySize(lots)-1 ? ", " : "");
        PrintFormat("Current %s lots: [%s]", EnumToString(type), lotStr);
    }
}

//+------------------------------------------------------------------+
//| ğŸ¯ CHECK IF MARTINGALE SHOULD BE ALLOWED                        |
//| Rule: Martingale only allowed when ALL existing positions in loss|
//+------------------------------------------------------------------+
bool ShouldAllowMartingale(ENUM_POSITION_TYPE type)
{
    // ğŸš¨ CRITICAL FIX: Check if trading is halted
    if(tradingHalted)
    {
        Print("ğŸš¨ Martingale not allowed: Trading is halted");
        return false;
    }

    // Variables to track positions
    int totalPositionsOfType = 0;
    int positionsInLoss = 0;
    double totalLoss = 0;

    // Loop through all positions
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;

        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if(posType != type) continue;

        totalPositionsOfType++;
        double profit = PositionGetDouble(POSITION_PROFIT);

        if(profit < -0.01) // Position is in loss (allowing small margin for precision)
        {
            positionsInLoss++;
            totalLoss += profit;
        }
    }

    // If no positions exist, martingale is allowed (first trade)
    if(totalPositionsOfType == 0) return true;

    // Martingale allowed ONLY if ALL existing positions are in loss
    bool allInLoss = (positionsInLoss == totalPositionsOfType);

    if(!allInLoss)
    {
        PrintFormat("Martingale BLOCKED: Type=%s, Total=%d, InLoss=%d, TotalLoss=$%.2f", 
                   EnumToString(type), totalPositionsOfType, positionsInLoss, totalLoss);
    }
    else
    {
        PrintFormat("Martingale ALLOWED: Type=%s, Total=%d all in loss, TotalLoss=$%.2f", 
                   EnumToString(type), totalPositionsOfType, totalLoss);
    }

    return allInLoss;
}

//+------------------------------------------------------------------+
//| ğŸ¯ GET MOST RECENT OPEN PRICE FOR MARTINGALE                    |
//+------------------------------------------------------------------+
double GetMostRecentOpenPrice(ENUM_POSITION_TYPE type)
{
    double mostRecentPrice = 0;
    datetime mostRecentTime = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;
        
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if(posType != type) continue;
        
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        if(openTime > mostRecentTime)
        {
            mostRecentTime = openTime;
            mostRecentPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        }
    }
    
    return mostRecentPrice;
}

//+------------------------------------------------------------------+
//| ğŸ¯ ENHANCED CAN PLACE MARTINGALE ORDER                          |
//| Includes: 1. Distance check 2. All positions must be in loss    |
//+------------------------------------------------------------------+
bool CanPlaceMartingaleOrder(ENUM_POSITION_TYPE type)
{
    if(OnlyManualTrading) return false;
    
    // ğŸ¯ CRITICAL RULE: Check if all existing positions are in loss
    if(!ShouldAllowMartingale(type))
    {
        PrintFormat("Martingale BLOCKED for %s: Not all positions are in loss",
                   EnumToString(type));
        return false;
    }
    
    // Get current open positions count
    int openPositions = (type == POSITION_TYPE_BUY) ? 
                       CountOpenPositionsOfType(POSITION_TYPE_BUY) : 
                       CountOpenPositionsOfType(POSITION_TYPE_SELL);
    
    if(openPositions == 0) return true; // First trade always allowed
    
    double currentPrice = (type == POSITION_TYPE_BUY) ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK) : 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Find the most recent open position price
    double lastPrice = GetMostRecentOpenPrice(type);
    
    if(lastPrice == 0) return true;
    
    double priceDiff = (type == POSITION_TYPE_BUY) ? 
                      (lastPrice - currentPrice) : 
                      (currentPrice - lastPrice);
    
    // Calculate required gap based on martingale level
    double requiredGap = 0;
    
    if(openPositions <= Order_dinamic_distance)
        requiredGap = PointsToPrice(Fix_Distance);
    else
    {
        int dynamicOrderIndex = openPositions - Order_dinamic_distance;
        requiredGap = PointsToPrice(Dynamic_distance_start * MathPow(Distance_multiplier, dynamicOrderIndex));
    }
    
    bool canPlace = (priceDiff >= requiredGap);
    
    if(canPlace)
    {
        PrintFormat("Martingale DISTANCE PASSED: Type=%s, Level=%d, Diff=%.1fpts, Required=%.1fpts",
                   EnumToString(type), openPositions, 
                   PriceToPoints(priceDiff), PriceToPoints(requiredGap));
    }
    else
    {
        PrintFormat("Martingale DISTANCE FAILED: Type=%s, Level=%d, Diff=%.1fpts, Required=%.1fpts",
                   EnumToString(type), openPositions, 
                   PriceToPoints(priceDiff), PriceToPoints(requiredGap));
    }
    
    return canPlace;
}

//+------------------------------------------------------------------+
//| ğŸš¨ UNIFIED MARTINGALE RESET - SINGLE SOURCE OF TRUTH            |
//+------------------------------------------------------------------+
void UnifiedMartingaleReset()
{
    // Check if ALL positions are truly closed
    int eaPositions = 0;
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket))
        {
            string symbol = PositionGetString(POSITION_SYMBOL);
            long magic = PositionGetInteger(POSITION_MAGIC);
            
            if(symbol == _Symbol && (magic == Magic || (ManualHandOrder && magic == 0)))
                eaPositions++;
        }
    }
    
    if(eaPositions == 0)
    {
        Print("=== ğŸš¨ UNIFIED MARTINGALE RESET ===");
        
        // Reset all sequences
        buyMartingaleSequence = 0;
        sellMartingaleSequence = 0;
        buyMartingaleLevel = 0;
        sellMartingaleLevel = 0;
        
        // Reset lot tracking
        lastBuyLot = 0.0;
        lastSellLot = 0.0;
        lastBuyPrice = 0.0;
        lastSellPrice = 0.0;
        
        // Reset tickets
        firstBuyLotTicket = 0;
        firstSellLotTicket = 0;
        
        // Reset series state
        seriesActive = false;
        currentSeriesDirection = WRONG_VALUE;
        
        // Reset break-even
        breakEvenPrice = 0.0;
        breakEvenActive = false;
        breakEvenTriggerPrice = 0.0;
        breakEvenBasePrice = 0.0;
        breakEvenPositionsClosed = 0;
        
        // Reset candle tracking
        candleTradeTaken = false;
        lastCandleTraded = 0;
        consecutiveMissedCandles = 0;
        
        positionsDirty = true;
        
        Print("âœ… Martingale COMPLETELY reset");
        Print("=================================");
    }
}

//+------------------------------------------------------------------+
//| ğŸ¯ APPLY TRADING MODE PRESETS                                   |
//| Sets internal flags based on master dropdown selection          |
//| â— DOES NOT MODIFY: Martingale, Overlap, Order Management       |
//| â— DOES NOT MODIFY: Grid Logic, SL/TP, Trade Engine             |
//+------------------------------------------------------------------+
void ApplyModeSettings()
{
   switch(TradingMode)
   {
      case MODE_DEFAULT:
         // ğŸ’š Original EA default behavior - all features active
         NewCycle_             = true;
         Flag_Trade_Buy_       = true;
         Flag_Trade_Sell_      = true;
         ManualHandOrder       = true;
         OnlyManualTrading     = false;
         GridSingleTradePerBar = true;
         Print("ğŸ› Trading Mode: DEFAULT - Full automated trading enabled");
      break;

      case MODE_BUY_ONLY:
         // ğŸŸ¢ Buy orders only - sell disabled
         Flag_Trade_Buy_       = true;
         Flag_Trade_Sell_      = false;
         OnlyManualTrading     = false;
         Print("ğŸ› Trading Mode: BUY ONLY - Only buy orders allowed");
      break;

      case MODE_SELL_ONLY:
         // ğŸ”´ Sell orders only - buy disabled  
         Flag_Trade_Buy_       = false;
         Flag_Trade_Sell_      = true;
         OnlyManualTrading     = false;
         Print("ğŸ› Trading Mode: SELL ONLY - Only sell orders allowed");
      break;

      case MODE_MANUAL_ONLY:
         // âœ‹ Manual trading mode only
         ManualHandOrder       = true;
         OnlyManualTrading     = true;
         Print("ğŸ› Trading Mode: MANUAL ONLY - EA manages existing positions only");
      break;

      case MODE_DISABLE_ALL:
         // ğŸš« Safety mode - no trading allowed
         Flag_Trade_Buy_       = false;
         Flag_Trade_Sell_      = false;
         ManualHandOrder       = false;
         OnlyManualTrading     = true;
         Print("ğŸ› Trading Mode: DISABLE ALL - Trading completely disabled");
      break;

      case MODE_CUSTOM:
         // âš™ï¸ User retains full manual control - no overrides
         Print("ğŸ› Trading Mode: CUSTOM - User controls all settings manually");
      break;
   }
   
   // ğŸ¯ Log the applied settings for transparency
   PrintFormat("ğŸ”§ Applied Settings: Buy=%s, Sell=%s, ManualHand=%s, OnlyManual=%s, GridSingleBar=%s",
               Flag_Trade_Buy_ ? "ON" : "OFF",
               Flag_Trade_Sell_ ? "ON" : "OFF", 
               ManualHandOrder ? "ON" : "OFF",
               OnlyManualTrading ? "ON" : "OFF",
               GridSingleTradePerBar ? "ON" : "OFF");
}

//+------------------------------------------------------------------+
//| ğŸ¯ APPLY PROFIT SETTING PRESET                                  |
//+------------------------------------------------------------------+
void ApplyProfitSettingPreset()
{
   switch(ProfitSetting)
   {
      case MODE_MY_SAFE:  // ğŸ›¡ Very Low Profit but Very Safe (DEFAULT)
         OverlapPointsDifference = 10;
         OverlapMinNetProfit     = 2;
         OverlapCheckFrequency   = 1;
         MinuteStop              = 0;
         CloseOldestFirst        = TRUE;
         RequireProfitForNextTrade = true;
         MinProfitDistance       = 5;
         Print("ğŸ› Profit Setting: MODE_MY_SAFE - Very Low Profit but Very Safe");
         break;
         
      case MODE_SUPER_SAFE:  // ğŸ§Š Ultra Safe â€“ Minimal Drawdown
         OverlapPointsDifference = 12;
         OverlapMinNetProfit     = 1;
         OverlapCheckFrequency   = 2;
         MinuteStop              = 1;
         CloseOldestFirst        = TRUE;
         RequireProfitForNextTrade = true;
         MinProfitDistance       = 8;
         Print("ğŸ› Profit Setting: MODE_SUPER_SAFE - Ultra Safe â€“ Minimal Drawdown");
         break;
         
      case MODE_MODERATE_SAFE:  // âš–ï¸ Moderate Profit â€“ Balanced Safety
         OverlapPointsDifference = 10;
         OverlapMinNetProfit     = 1.8;
         OverlapCheckFrequency   = 2;
         MinuteStop              = 0;
         CloseOldestFirst        = TRUE;
         RequireProfitForNextTrade = false;
         MinProfitDistance       = 6;
         Print("ğŸ› Profit Setting: MODE_MODERATE_SAFE - Moderate Profit â€“ Balanced Safety");
         break;
         
      case MODE_RISKY_PROFIT:  // ğŸ”¥ High Profit â€“ Risky but Still Safe
         OverlapPointsDifference = 8;
         OverlapMinNetProfit     = 2.5;
         OverlapCheckFrequency   = 1;
         MinuteStop              = 0;
         CloseOldestFirst        = TRUE;
         RequireProfitForNextTrade = false;
         MinProfitDistance       = 4;
         Print("ğŸ› Profit Setting: MODE_RISKY_PROFIT - High Profit â€“ Risky but Still Safe");
         break;
   }
   
   // Log the applied settings
   PrintFormat("ğŸ”§ Applied Overlap Settings: PointsDiff=%d, MinNetProfit=%.2f, CheckFreq=%d",
               OverlapPointsDifference, OverlapMinNetProfit, OverlapCheckFrequency);
   PrintFormat("ğŸ”§ Additional Settings: MinuteStop=%d, CloseOldest=%s, RequireProfit=%s, MinDist=%d",
               MinuteStop, CloseOldestFirst ? "TRUE" : "FALSE", 
               RequireProfitForNextTrade ? "TRUE" : "FALSE", MinProfitDistance);
}

//===============================================================
// 1. ENHANCED POSITION MONITORING SYSTEM
//===============================================================

void EnhancedPositionMonitoring()
{
    static int lastPositionCount = -1;
    int currentPositionCount = CountAllEAPositions();
    
    // Check for position count change
    if(lastPositionCount != currentPositionCount)
    {
        PrintFormat("ğŸ” Position Monitor: Count changed from %d to %d", 
                   lastPositionCount, currentPositionCount);
        
        if(lastPositionCount > 0 && currentPositionCount == 0)
        {
            Print("ğŸš¨ ALERT: All positions closed - Triggering immediate martingale reset!");
            ForceMartingaleResetImmediate();
        }
        
        lastPositionCount = currentPositionCount;
    }
}

//===============================================================
// 2. COMPREHENSIVE POSITION COUNTING
//===============================================================

int CountAllEAPositions()
{
    int count = 0;
    
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket))
        {
            string symbol = PositionGetString(POSITION_SYMBOL);
            long magic = PositionGetInteger(POSITION_MAGIC);
            
            // Count ALL EA-managed positions
            if(symbol == _Symbol)
            {
                if(ManualHandOrder && magic == 0) // Manual positions when allowed
                    count++;
                else if(magic == Magic) // EA's magic number positions
                    count++;
            }
        }
    }
    
    return count;
}

//===============================================================
// 3. IMMEDIATE MARTINGALE RESET (NO DELAYS)
//===============================================================

void ForceMartingaleResetImmediate()
{
    // No delays, no cooldowns - immediate reset
    Print("==================================================================");
    Print("ğŸš¨ FORCE MARTINGALE RESET - IMMEDIATE");
    Print("==================================================================");
    
    // Reset all sequences
    buyMartingaleSequence = 0;
    sellMartingaleSequence = 0;
    buyMartingaleLevel = 0;
    sellMartingaleLevel = 0;
    
    // Reset lot tracking
    lastBuyLot = 0.0;
    lastSellLot = 0.0;
    lastBuyPrice = 0.0;
    lastSellPrice = 0.0;
    
    // Reset tickets
    firstBuyLotTicket = 0;
    firstSellLotTicket = 0;
    
    // Reset series state
    seriesActive = false;
    currentSeriesDirection = WRONG_VALUE;
    
    // Reset break-even
    breakEvenPrice = 0.0;
    breakEvenActive = false;
    breakEvenTriggerPrice = 0.0;
    breakEvenBasePrice = 0.0;
    breakEvenPositionsClosed = 0;
    
    // Reset candle tracking
    candleTradeTaken = false;
    lastCandleTraded = 0;
    consecutiveMissedCandles = 0;
    
    // Force cache update
    positionsDirty = true;
    
    // Verify reset
    Print("âœ… Martingale IMMEDIATELY reset to:");
    PrintFormat("   Buy Sequence: %d, Sell Sequence: %d", buyMartingaleSequence, sellMartingaleSequence);
    PrintFormat("   Last Buy Lot: %.3f, Last Sell Lot: %.3f", lastBuyLot, lastSellLot);
    Print("==================================================================");
}

//===============================================================
// 4. ENHANCED POSITION CLOSURE DETECTION
//===============================================================

bool EnhancedSafePositionClose(ulong ticket)
{
    if(!SafePositionCloseImmediate(ticket))
        return false;
    
    // IMMEDIATELY check if chart is empty after closure
    if(CountAllEAPositions() == 0)
    {
        Print("ğŸ¯ Position closed - Chart is now EMPTY. Triggering immediate reset!");
        ForceMartingaleResetImmediate();
    }
    
    return true;
}

//===============================================================
// 5. ENHANCED TEST FUNCTION TO VERIFY RESET
//===============================================================

void TestMartingaleResetScenario()
{
    Print("====================================================");
    Print("ğŸ§ª MARTINGALE RESET TEST SCENARIO");
    Print("====================================================");
    
    // Test Case 1: Empty chart
    if(CountAllEAPositions() == 0)
    {
        Print("âœ… Test 1: Empty chart - Sequences should be 0");
        PrintFormat("   Buy Sequence: %d (Expected: 0)", buyMartingaleSequence);
        PrintFormat("   Sell Sequence: %d (Expected: 0)", sellMartingaleSequence);
        
        if(buyMartingaleSequence == 0 && sellMartingaleSequence == 0)
            Print("âœ… Test 1 PASSED!");
        else
        {
            Print("âŒ Test 1 FAILED! Forcing reset...");
            ForceMartingaleResetImmediate();
        }
    }
    
    // Test Case 2: Verify lot sizes
    PrintFormat("   Last Buy Lot: %.3f (Expected: 0.000)", lastBuyLot);
    PrintFormat("   Last Sell Lot: %.3f (Expected: 0.000)", lastSellLot);
    
    if(lastBuyLot == 0.0 && lastSellLot == 0.0)
        Print("âœ… Lot tracking reset correctly!");
    else
        Print("âš ï¸ Lot tracking not reset!");
    
    // Test Case 3: Verify series state
    if(!seriesActive && currentSeriesDirection == WRONG_VALUE)
        Print("âœ… Series state reset correctly!");
    else
        Print("âš ï¸ Series state not reset!");
    
    Print("====================================================");
}

//+------------------------------------------------------------------+
//| ğŸ•¯ FIXED ONE TRADE PER CANDLE CHECK                             |
//+------------------------------------------------------------------+
bool CanTradeCurrentCandleSimple()
{
    if(EnableOneTradePerCandle != TRUE) return true;
    
    datetime currentCandle = iTime(_Symbol, TradeTimeframe, 0);
    
    if(currentCandle != lastCandleTraded)
    {
        lastCandleTraded = currentCandle;
        candleTradeTaken = false;
        consecutiveMissedCandles = 0;
        Print("ğŸ•¯ New candle detected: ", TimeToString(currentCandle), " | TF: ", EnumToString(TradeTimeframe));
        return true;
    }
    
    return !candleTradeTaken;
}

//+------------------------------------------------------------------+
//| ğŸ•¯ FIXED FORCE TRADE ON CURRENT CANDLE                          |
//+------------------------------------------------------------------+
void ForceTradeOnCurrentCandle()
{
    if(EnableOneTradePerCandle != TRUE || ForceTradeEveryCandle != TRUE)
        return;

    // ğŸš¨ CRITICAL FIX: STOP EXECUTION IF TRADING IS HALTED
    if(tradingHalted)
    {
        if(EnableDebugLog)
            Print("ğŸš¨ Force Trade: Trading halted, skipping forced trades");
        return;
    }

    datetime currentCandle = iTime(_Symbol, TradeTimeframe, 0);

    // Already traded this candle?
    if(candleTradeTaken && currentCandle == lastCandleTraded) 
    {
        return;
    }

    // Check if we're in the last 40% of candle time
    datetime candleStart = currentCandle;
    long candleDuration = PeriodSeconds(TradeTimeframe);
    datetime candleEnd = candleStart + (datetime)candleDuration;
    datetime currentTime = TimeCurrent();

    // Don't force trade in first 30% of candle
    double candleProgress = double(currentTime - candleStart) / double(candleDuration);

    if(candleProgress < 0.3) 
    {
        // Wait until we're at least 30% into the candle
        return;
    }

    // Force trade if we're in the last 40% of candle time and haven't traded yet
    if(candleProgress >= 0.6 && (currentTime - lastForcedTradeTime) >= candleDuration)
    {
        if(!candleTradeTaken)
        {
            PrintFormat("ğŸ•¯âš ï¸ Candle at %d%% progress - forcing trade to avoid missed candle!", 
                        int(candleProgress * 100));

            // Determine trade direction
            ENUM_ORDER_TYPE forcedType = DetermineForcedTradeDirection();

            if(forcedType != WRONG_VALUE)
            {
                Print("ğŸ•¯ğŸ”¥ Forcing trade on candle: ", TimeToString(currentCandle), 
                      " | Type: ", EnumToString(forcedType),
                      " | Progress: ", int(candleProgress * 100), "%");

                OpenTrade(forcedType, true);
                lastForcedTradeTime = currentTime;

                // Mark candle as traded
                candleTradeTaken = true;
                lastCandleTraded = currentCandle;
            }
            else
            {
                consecutiveMissedCandles++;
                PrintFormat("ğŸ•¯âŒ No valid direction for forced trade. Consecutive misses: %d", 
                            consecutiveMissedCandles);

                // If we miss too many candles, use simple direction
                if(consecutiveMissedCandles >= 2)
                {
                    forcedType = GetSimpleTradeDirection();
                    if(forcedType != WRONG_VALUE)
                    {
                        Print("ğŸ•¯ğŸš€ Using simple direction after multiple misses: ", 
                              EnumToString(forcedType));

                        OpenTrade(forcedType, true);
                        lastForcedTradeTime = currentTime;
                        candleTradeTaken = true;
                        lastCandleTraded = currentCandle;
                        consecutiveMissedCandles = 0;
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| ğŸ•¯ SIMPLE TRADE DIRECTION FALLBACK                              |
//+------------------------------------------------------------------+
ENUM_ORDER_TYPE GetSimpleTradeDirection()
{
    double maValue = GetGridMAValue();
    if(maValue <= 0) return WRONG_VALUE;
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // If we have active series, follow it
    if(seriesActive)
    {
        if(currentSeriesDirection == POSITION_TYPE_BUY)
            return ORDER_TYPE_BUY;
        else if(currentSeriesDirection == POSITION_TYPE_SELL)
            return ORDER_TYPE_SELL;
    }
    
    // Otherwise use MA
    if(currentPrice > maValue)
        return ORDER_TYPE_BUY;
    else
        return ORDER_TYPE_SELL;
}

//+------------------------------------------------------------------+
//| ğŸ•¯ DETERMINE FORCED TRADE DIRECTION                             |
//+------------------------------------------------------------------+
ENUM_ORDER_TYPE DetermineForcedTradeDirection()
{
    // Priority 1: Use current series direction
    if(seriesActive)
    {
        if(currentSeriesDirection == POSITION_TYPE_BUY)
        {
            Print("ğŸ•¯ Using current series direction: BUY");
            return ORDER_TYPE_BUY;
        }
        else if(currentSeriesDirection == POSITION_TYPE_SELL)
        {
            Print("ğŸ•¯ Using current series direction: SELL");
            return ORDER_TYPE_SELL;
        }
    }
    
    // Priority 2: Use strategy signals
    if(Use_Stoh == TRUE)
    {
        ENUM_ORDER_TYPE stochSignal = GetStochasticSignal();
        if(stochSignal != WRONG_VALUE)
        {
            Print("ğŸ•¯ Using Stochastic signal: ", EnumToString(stochSignal));
            return stochSignal;
        }
    }
    else
    {
        ENUM_ORDER_TYPE maSignal = GetMASignal();
        if(maSignal != WRONG_VALUE)
        {
            Print("ğŸ•¯ Using MA signal: ", EnumToString(maSignal));
            return maSignal;
        }
    }
    
    // Priority 3: Use MA fallback
    double maValue = GetGridMAValue();
    if(maValue > 0)
    {
        double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        if(currentPrice > maValue)
        {
            Print("ğŸ•¯ Using MA fallback: BUY (Price above MA)");
            return ORDER_TYPE_BUY;
        }
        else
        {
            Print("ğŸ•¯ Using MA fallback: SELL (Price below MA)");
            return ORDER_TYPE_SELL;
        }
    }
    
    return WRONG_VALUE;
}

//+------------------------------------------------------------------+
//| ğŸ•¯ GET STOCHASTIC SIGNAL FOR FORCED TRADE                       |
//+------------------------------------------------------------------+
ENUM_ORDER_TYPE GetStochasticSignal()
{
    if(hStochastic == INVALID_HANDLE) return WRONG_VALUE;
    
    double stochMain[], stochSignal[];
    ArraySetAsSeries(stochMain, true);
    ArraySetAsSeries(stochSignal, true);
    
    if(CopyBuffer(hStochastic, 0, 0, 3, stochMain) != 3) return WRONG_VALUE;
    if(CopyBuffer(hStochastic, 1, 0, 3, stochSignal) != 3) return WRONG_VALUE;
    
    double currentK = stochMain[0];
    double currentD = stochSignal[0];
    double prevK = stochMain[1];
    
    if(prevK < Down_Level && currentK > Down_Level) 
    {
        Print("ğŸ•¯ Stochastic oversold - BUY signal");
        return ORDER_TYPE_BUY;
    }
    else if(prevK > Up_Level && currentK < Up_Level)
    {
        Print("ğŸ•¯ Stochastic overbought - SELL signal");
        return ORDER_TYPE_SELL;
    }
    
    return WRONG_VALUE;
}

//+------------------------------------------------------------------+
//| ğŸ•¯ GET MA SIGNAL FOR FORCED TRADE                               |
//+------------------------------------------------------------------+
ENUM_ORDER_TYPE GetMASignal()
{
    double maValue = GetGridMAValue();
    if(maValue <= 0) return WRONG_VALUE;
    
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    if(currentPrice > maValue)
    {
        Print("ğŸ•¯ Price above MA - BUY signal");
        return ORDER_TYPE_BUY;
    }
    else
    {
        Print("ğŸ•¯ Price below MA - SELL signal");
        return ORDER_TYPE_SELL;
    }
}

//+------------------------------------------------------------------+
//| ğŸ•¯ FIXED OPEN TRADE FUNCTION - TRADING HALT REINFORCED          |
//+------------------------------------------------------------------+
void OpenTrade(ENUM_ORDER_TYPE type, bool forcedTrade = false)
{
    // ğŸš¨ CRITICAL FIX: Trading halted check for ALL trade types
    if(tradingHalted && !forcedTrade)
    {
        Print("ğŸš¨ OPEN TRADE BLOCKED: Trading is halted");
        return;
    }

    if(OnlyManualTrading && !forcedTrade)
    {
        if(EnableDebugLog) Print("BLOCKED: Trade attempted in Manual Trading Mode");
        return;
    }

    if(!forcedTrade && (!IsTradingAllowed() || stopLossHit || tradingHalted || isProcessing)) 
    {
        if(EnableDebugLog) Print("BLOCKED: Trading not allowed or processing");
        return;
    }

    isProcessing = true;

    // ğŸ•¯ ONE TRADE PER CANDLE CHECK (unless forced trade)
    if(!forcedTrade && EnableOneTradePerCandle == TRUE && !CanTradeCurrentCandleSimple())
    {
        if(EnableDebugLog) Print("ğŸ•¯ Trade blocked: Already traded current candle on ", EnumToString(TradeTimeframe));
        isProcessing = false;
        return;
    }

    ENUM_POSITION_TYPE posType = (type == ORDER_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;

    int openPositionsCount = (posType == POSITION_TYPE_BUY) ? 
                              CountOpenPositionsOfType(POSITION_TYPE_BUY) : 
                              CountOpenPositionsOfType(POSITION_TYPE_SELL);

    double lotSize = CalculateMartingaleLotSize(posType);

    // For forced trades, use base lot if martingale conditions aren't met
    if(forcedTrade && lotSize <= 0)
    {
        lotSize = GetBaseLotSize();
        Print("ğŸ•¯ Forced trade using base lot: ", lotSize);
    }

    // ğŸ¯ CRITICAL: Check martingale conditions (distance AND all positions in loss)
    if(openPositionsCount > 0)
    {
        if(!CanPlaceMartingaleOrder(posType))
        {
            PrintFormat("Martingale BLOCKED for %s #%d: Conditions not met",
                       EnumToString(posType), openPositionsCount + 1);
            isProcessing = false;
            return;
        }
    }

    MqlTick tick;
    if(!SymbolInfoTick(_Symbol, tick)) 
    {
        isProcessing = false; 
        return; 
    }

    double price = (type == ORDER_TYPE_BUY) ? tick.ask : tick.bid;
    double marginRequired = 0.0;

    // Margin check
    if(!forcedTrade && (!OrderCalcMargin(ORDER_TYPE_BUY, _Symbol, lotSize, price, marginRequired) ||
       AccountInfoDouble(ACCOUNT_MARGIN_FREE) < marginRequired * 1.1))
    { 
        Print("Margin check failed: Required=", marginRequired, ", Free=", AccountInfoDouble(ACCOUNT_MARGIN_FREE));
        isProcessing = false; 
        return; 
    }

    MqlTradeRequest request;
    MqlTradeResult result;
    ZeroMemory(request); 
    ZeroMemory(result);

    request.action    = TRADE_ACTION_DEAL;
    request.symbol    = _Symbol;
    request.volume    = lotSize;
    request.type      = type;
    request.price     = price;
    request.deviation = 10;
    request.magic     = Magic;
    request.comment   = forcedTrade ? "Forced_Candle_Trade" : sOrdComm;

    // ğŸ¯ FIXED: Use corrected point calculation for SL
    if(SL_Mode == SL_MODE_POINTS && SL_ > 0)
    {
        double slPoints = PointsToPrice(SL_);
        request.sl = (type == ORDER_TYPE_BUY) ? price - slPoints : price + slPoints;
    }

    bool success = OrderSend(request, result);

    if(success && result.retcode == TRADE_RETCODE_DONE)
    {
        // ğŸ•¯ MARK CANDLE AS TRADED
        if(EnableOneTradePerCandle == TRUE)
        {
            candleTradeTaken = true;

            if(forcedTrade)
                Print("ğŸ•¯ğŸ”¥ FORCED Trade executed on candle: ", TimeToString(lastCandleTraded), " | TF: ", EnumToString(TradeTimeframe));
            else
                Print("ğŸ•¯ Trade executed on candle: ", TimeToString(lastCandleTraded), " | TF: ", EnumToString(TradeTimeframe));
        }

        // Update first lot tracking
        if(openPositionsCount == 0) // This is the first position
        {
            if(type == ORDER_TYPE_BUY  && firstBuyLotTicket == 0)  
            {
                firstBuyLotTicket  = result.order;
                initialBuyBaseLot = lotSize;
            }
            if(type == ORDER_TYPE_SELL && firstSellLotTicket == 0) 
            {
                firstSellLotTicket = result.order;
                initialSellBaseLot = lotSize;
            }
        }

        // Update tracking
        if(type == ORDER_TYPE_BUY)
        {
            lastBuyPrice = price;
            lastBuyLot = lotSize;
            lastBuyTradeTime = TimeCurrent();
            PrintFormat("BUY #%d: %.4f lots at %.5f (OpenPositions=%d)", 
                       openPositionsCount + 1, lotSize, price, openPositionsCount + 1);
        }
        else
        {
            lastSellPrice = price;
            lastSellLot = lotSize;
            lastSellTradeTime = TimeCurrent();
            PrintFormat("SELL #%d: %.4f lots at %.5f (OpenPositions=%d)", 
                       openPositionsCount + 1, lotSize, price, openPositionsCount + 1);
        }

        lastTradeTime  = TimeCurrent();
        positionsDirty = true;

        // Force immediate recalculation
        RecalculateMartingaleState();

        if(openPositionsCount >= 1) // Now we have at least 2 positions
            UpdateFirstLotTPLines();

        LogOrderOpen(type, lotSize, price, request.sl, 0, result.order);
    }
    else
    {
        if(forcedTrade)
            Print("ğŸ•¯âŒ FORCED Trade failed: ", result.retcode);
        else
            LogOrderFailure("Open Trade", 0, result.retcode, "Failed to open trade");
    }

    isProcessing = false;
}

//+------------------------------------------------------------------+
//| ğŸ¯ FIXED FIRST LOT TP CALCULATION                               |
//+------------------------------------------------------------------+
void CheckFirstMartingaleLotTP()
{
    if(EnableFirstLotTP != TRUE) return;
    
    // For XAUUSD (3-digit broker): 1 point = 0.01, 100 points = 1.00
    double tpPoints = FirstLotTPPoints; // 1000 points = 10.00 price movement
    
    if(firstBuyLotTicket != 0 && buyMartingaleSequence >= 1)
    {
        if(PositionSelectByTicket(firstBuyLotTicket))
        {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            
            // Calculate TP price: openPrice + (points Ã— point value)
            double tpPrice = openPrice + (tpPoints * g_point);
            
            PrintFormat("ğŸ¯ BUY TP: Open=%.2f, TP=%.2f, Current=%.2f, Points=%d, Point=%.5f",
                       openPrice, tpPrice, currentBid, tpPoints, g_point);
            
            if(currentBid >= tpPrice)
            {
                PrintFormat("ğŸ¯âœ… FIRST BUY TP HIT! Closing at %.2f", currentBid);
                
                if(EnhancedSafePositionClose(firstBuyLotTicket))
                {
                    firstBuyLotTicket = 0;
                    ObjectDelete(0, "FirstBuyTPLine");
                    ObjectDelete(0, "FirstBuyTPText");
                }
            }
        }
        else
        {
            firstBuyLotTicket = 0;
        }
    }
    
    if(firstSellLotTicket != 0 && sellMartingaleSequence >= 1)
    {
        if(PositionSelectByTicket(firstSellLotTicket))
        {
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            
            double tpPrice = openPrice - (tpPoints * g_point);
            
            PrintFormat("ğŸ¯ SELL TP: Open=%.2f, TP=%.2f, Current=%.2f, Points=%d, Point=%.5f",
                       openPrice, tpPrice, currentAsk, tpPoints, g_point);
            
            if(currentAsk <= tpPrice)
            {
                PrintFormat("ğŸ¯âœ… FIRST SELL TP HIT! Closing at %.2f", currentAsk);
                
                if(EnhancedSafePositionClose(firstSellLotTicket))
                {
                    firstSellLotTicket = 0;
                    ObjectDelete(0, "FirstSellTPLine");
                    ObjectDelete(0, "FirstSellTPText");
                }
            }
        }
        else
        {
            firstSellLotTicket = 0;
        }
    }
}

//+------------------------------------------------------------------+
//| ğŸ‰ ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½ ENHANCED LOGGING SYSTEM                        |
//|                Professional Dashboard Logging                   |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ğŸ¯ INITIALIZATION LOGGING - MATRIX STYLE                        |
//+------------------------------------------------------------------+
void LogEAInitialization()
{
    if(!EnableEnhancedLogging) return;
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                           â˜… ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½ EA v3.16 â˜…                          â•‘");
    Print("â•‘                 â—† ENHANCED POSITION MONITORING SYSTEM â—†                     â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("");

    // ğŸ“Š TRADING MODE DISPLAY
    string modeText = "";
    switch(TradingMode)
    {
       case MODE_DEFAULT:    modeText = "DEFAULT ğŸ’š"; break;
       case MODE_BUY_ONLY:   modeText = "BUY ONLY ğŸŸ¢"; break; 
       case MODE_SELL_ONLY:  modeText = "SELL ONLY ğŸ”´"; break;
       case MODE_MANUAL_ONLY:modeText = "MANUAL ONLY âœ‹"; break;
       case MODE_DISABLE_ALL:modeText = "DISABLE ALL ğŸš«"; break;
       case MODE_CUSTOM:     modeText = "CUSTOM âš™ï¸"; break;
    }
    
    Print("ğŸ‰ğŸ“Š BASIC PARAMETERS");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                       â˜… BASIC PARAMETERS â˜…                         â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                           â•‘ Value                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

    string s_time    = TimeToString(TimeCurrent(), TIME_MINUTES);
    string s_cycle   = NewCycle_         ? "âœ” TRUE"  : "âœ– FALSE";
    string s_buy     = Flag_Trade_Buy_   ? "âœ” TRUE"  : "âœ– FALSE";
    string s_sell    = Flag_Trade_Sell_  ? "âœ” TRUE"  : "âœ– FALSE";
    string s_manual  = ManualHandOrder   ? "âœ” TRUE"  : "âœ– FALSE";
    string s_onlyman = OnlyManualTrading ? "âœ” TRUE"  : "âœ– FALSE";

    Print("â•‘ â–º Server Time                       â•‘ ", s_time, "                        â•‘");
    Print("â•‘ â–º Master Trading Mode               â•‘ ", modeText, "                 â•‘");
    Print("â•‘ â–º New Cycle                         â•‘ ", s_cycle, "                      â•‘");
    Print("â•‘ â–º Buy Enabled                       â•‘ ", s_buy, "                      â•‘");
    Print("â•‘ â–º Sell Enabled                      â•‘ ", s_sell, "                      â•‘");
    Print("â•‘ â–º Manual Orders                     â•‘ ", s_manual, "                      â•‘");
    Print("â•‘ â–º Manual Only Mode                  â•‘ ", s_onlyman, "                     â•‘");

    Print("â•‘ â–º Spread Limit                      â•‘ ", MaxSpred, " pips                     â•‘");
    Print("â•‘ â–º Trading Hours                     â•‘ ", Start_Hour, " to ", End_Hour, "               â•‘");
    Print("â•‘ â–º Magic Number                      â•‘ ", Magic, "                          â•‘");

    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("ğŸ‰âœ” PARAMETERS LOADED SUCCESSFULLY âœ”ğŸ‰");

    // ğŸ“ˆ STRATEGY SETTINGS MATRIX
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                           ğŸ“ˆ STRATEGY SETTINGS                               â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                    â•‘ Value                         â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Initial Lot                                  â•‘ ", DoubleToString(Lot_Init_, 2), " ğŸ¯                       â•‘");
    Print("â•‘ First Lot TP                                 â•‘ ", EnableFirstLotTP ? "TRUE âœ…" : "FALSE âŒ", " | ", FirstLotTPPoints, " pts             â•‘");
    Print("â•‘ Profit Setting                               â•‘ ", EnumToString(ProfitSetting), "       â•‘");
    Print("â•‘ SL Mode                                      â•‘ ", SL_Mode == 0 ? "NONE ğŸ›¡" : "POINTS âš”", " | ", SL_, " pts               â•‘");
    Print("â•‘ Virtual Stop Loss                            â•‘ ", EnableVirtualStopLoss ? "TRUE ğŸ‘»" : "FALSE âŒ", " | ", StopLossPoints, " pts         â•‘");
    Print("â•‘ Auto Lot                                     â•‘ ", Autolot_ ? "TRUE âš–" : "FALSE âŒ", " | Factor: ", Autolotsize_, "       â•‘");
    Print("â•‘ Close Oldest First                           â•‘ ", CloseOldestFirst ? "TRUE ğŸ”„" : "FALSE âŒ", "                       â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // â™Ÿï¸ MARTINGALE SYSTEM MATRIX
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          ï¸ MARTINGALE SYSTEM                                  â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                    â•‘ Value                         â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Type                                         â•‘ ", MartingaleType == MARTIN_MULTIPLIER ? "MULTIPLIER ğŸ”º" : "FIXED STEP â•", "                  â•‘");
    Print("â•‘ Multiplier Factor                            â•‘ ", DoubleToString(MultiplierFactor, 2), " âœ–                        â•‘");
    Print("â•‘ Fixed Step Lots                              â•‘ ", DoubleToString(FixedStepLots, 2), " â•                        â•‘");
    Print("â•‘ Max Concurrent Orders                        â•‘ ", MaxConcurrentOrders, " ğŸ”¢                          â•‘");
    Print("â•‘ Require Profit for Next                      â•‘ ", RequireProfitForNextTrade ? "TRUE ğŸ’°" : "FALSE âŒ", "                        â•‘");
    Print("â•‘ Fixed Distance                               â•‘ ", Fix_Distance, " pips ğŸ“Œ                    â•‘");
    Print("â•‘ Dynamic Start                                â•‘ ", Dynamic_distance_start, " pips ğŸš€                    â•‘");
    Print("â•‘ Distance Multiplier                          â•‘ ", DoubleToString(Distance_multiplier, 2), " âœ¨                        â•‘");
    Print("â•‘ Max Lot                                      â•‘ ", DoubleToString(MaxLot_, 2), " ğŸ‹ï¸ âš ï¸                      â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    // ğŸš¨ ENHANCED POSITION MONITORING SECTION
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                     ğŸš¨ ENHANCED POSITION MONITORING SYSTEM ğŸš¨               â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Feature                                      â•‘ Status                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Immediate Martingale Reset                   â•‘ âœ… ENABLED ğŸ’š                  â•‘");
    Print("â•‘ Position Count Monitoring                   â•‘ âœ… ENABLED ğŸ’š                  â•‘");
    Print("â•‘ Multiple Reset Triggers                     â•‘ âœ… ENABLED ğŸ’š                  â•‘");
    Print("â•‘ 5-Second Debug Logging                      â•‘ âœ… ENABLED ğŸ’š                  â•‘");
    Print("â•‘ State Inconsistency Detection               â•‘ âœ… ENABLED ğŸ’š                  â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    Print("");
    Print("âœ… ENHANCED POSITION MONITORING SYSTEM INITIALIZED ğŸš€");
    Print("");
}

//+------------------------------------------------------------------+
//| ğŸŸ¢ ORDER EXECUTION LOGGING - MATRIX STYLE                       |
//+------------------------------------------------------------------+
void LogOrderOpen(ENUM_ORDER_TYPE type, double lot, double price, double sl, double tp, ulong ticket)
{
    if(!EnableEnhancedLogging) return;
    
    string orderType = (type == ORDER_TYPE_BUY) ? "BUY ğŸŸ¢â¬†ï¸" : "SELL ğŸ”´â¬‡ï¸";
    string slText = (sl > 0) ? DoubleToString(sl, 5) : "NONE ğŸš«";
    string tpText = (tp > 0) ? DoubleToString(tp, 5) : "NONE ğŸš«";
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          âœ… NEW ORDER OPENED âœ…                                â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                     â•‘ Value                         â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Type                                          â•‘ ", orderType, "                       â•‘");
    Print("â•‘ Ticket                                        â•‘ ", ticket, " ğŸŸï¸                        â•‘");
    Print("â•‘ Lot Size                                      â•‘ ", DoubleToString(lot, 2), " ğŸ“¦                        â•‘");
    Print("â•‘ Entry Price                                   â•‘ ", DoubleToString(price, 5), " ğŸ’°                  â•‘");
    Print("â•‘ Stop Loss                                     â•‘ ", slText, " ğŸ›‘                     â•‘");
    Print("â•‘ Take Profit                                   â•‘ ", tpText, " ğŸ¯                     â•‘");
    Print("â•‘ Time                                          â•‘ ", TimeToString(TimeCurrent(), TIME_SECONDS), "                      â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("");
}

//+------------------------------------------------------------------+
//| âŒ ORDER CLOSE LOGGING - MATRIX STYLE                           |
//+------------------------------------------------------------------+
void LogOrderClose(ulong ticket, double profit, string reason)
{
    if(!EnableEnhancedLogging) return;
    
    string resultEmoji = (profit >= 0) ? "ğŸ’° PROFIT ğŸ’¹" : "ğŸ’¸ LOSS ğŸ“‰";
    string boxTitle = (profit >= 0) ? "ğŸ’° ORDER CLOSED - PROFIT ğŸ’¹" : "ğŸ’¸ ORDER CLOSED - LOSS ğŸ“‰";
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          ", boxTitle, "                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                    â•‘ Value                       â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Ticket                                       â•‘ ", ticket, " ğŸŸï¸           â•‘");
    Print("â•‘ Result                                       â•‘ ", resultEmoji, "               â•‘");
    Print("â•‘ Profit/Loss                                  â•‘ $", DoubleToString(profit, 2), " ", (profit >= 0 ? "âœ…" : "âŒ"), "            â•‘");
    Print("â•‘ Reason                                       â•‘ ", reason, "                   â•‘");
    Print("â•‘ Close Time                                   â•‘ ", TimeToString(TimeCurrent(), TIME_SECONDS), "        â•‘");
    Print("â•‘ Cumulative Profit                            â•‘ $", DoubleToString(cumulativeRealizedProfit, 2), " ğŸ“Š      â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("");
}

//+------------------------------------------------------------------+
//| âš ï¸ ORDER FAILURE LOGGING                                        |
//+------------------------------------------------------------------+
void LogOrderFailure(string operation, ulong ticket, int errorCode, string details)
{
    if(!EnableEnhancedLogging) return;
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                    âŒ ORDER OPERATION FAILED âš ï¸               â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("ğŸ”¹ Operation: ", operation);
    Print("ğŸ”¹ Ticket: ", ticket, " ğŸŸï¸");
    Print("ğŸ”¹ Error Code: ", errorCode, " ğŸš«");
    Print("ğŸ”¹ Details: ", details);
    Print("ğŸ”¹ Time: ", TimeToString(TimeCurrent(), TIME_SECONDS));
    Print("");
}

//+------------------------------------------------------------------+
//| ğŸ“Š POSITION DASHBOARD - ADVANCED MATRIX                         |
//+------------------------------------------------------------------+
void LogPositionDashboard()
{
    if(!EnableEnhancedLogging) return;

    int buyPositions     = GetCachedBuyPositions();
    int sellPositions    = GetCachedSellPositions();
    double totalProfit   = cachedBuyProfit + cachedSellProfit;
    double totalVolume   = cachedBuyVolume + cachedSellVolume;

    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          LIVE POSITIONS DASHBOARD                            â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Direction     â•‘ Count  â•‘ Volume     â•‘ P/L ($)    â•‘ P/L (%)    â•‘ Status       â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

    // BUY
    string buyStatus   = (cachedBuyProfit >= 0) ? "PROFIT ğŸ’¹" : "LOSS ğŸ“‰";
    double buyPercent  = (cachedBalance > 0) ? (cachedBuyProfit  / cachedBalance * 100) : 0;

    Print("â•‘ BUY           â•‘ ",
           StringFormat("%-6d", buyPositions),
           " â•‘",
           StringFormat("%-10.2f", cachedBuyVolume),
           "  â•‘ ",
           StringFormat("%-10.2f", cachedBuyProfit),
           " â•‘ ",
           StringFormat("%-10.2f", buyPercent),
           " â•‘ ",
           StringFormat("%-12s", buyStatus),
           " â•‘");

    // SELL
    string sellStatus  = (cachedSellProfit >= 0) ? "PROFIT ğŸ’¹" : "LOSS ğŸ“‰";
    double sellPercent = (cachedBalance > 0) ? (cachedSellProfit / cachedBalance * 100) : 0;

    Print("â•‘ SELL          â•‘ ",
           StringFormat("%-6d", sellPositions),
           " â•‘ ",
           StringFormat("%-10.2f", cachedSellVolume),
           " â•‘ ",
           StringFormat("%-10.2f", cachedSellProfit),
           " â•‘ ",
           StringFormat("%-10.2f", sellPercent),
           " â•‘ ",
           StringFormat("%-12s", sellStatus),
           " â•‘");

    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

    // TOTAL
    string totalStatus = (totalProfit >= 0) ? "PROFIT ğŸ’°" : "LOSS ğŸ”»";
    double totalPercent = (cachedBalance > 0) ? (totalProfit / cachedBalance * 100) : 0;

    Print("â•‘ TOTAL         â•‘ ",
           StringFormat("%-6d", buyPositions + sellPositions),
           " â•‘ ",
           StringFormat("%-10.2f", totalVolume),
           " â•‘ ",
           StringFormat("%-10.2f", totalProfit),
           " â•‘ ",
           StringFormat("%-10.2f", totalPercent),
           " â•‘ ",
           StringFormat("%-12s", totalStatus),
           "  â•‘");

    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    Print("ğŸ• Dashboard Time: ", TimeToString(TimeCurrent(), TIME_SECONDS));
}

//+------------------------------------------------------------------+
//| ğŸ’° ACCOUNT STATUS MATRIX                                        |
//+------------------------------------------------------------------+
void LogAccountStatus()
{
    if(!EnableEnhancedLogging) return;
    
    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double floating = equity - balance;
    double margin = AccountInfoDouble(ACCOUNT_MARGIN);
    double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
    double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL);
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          ğŸ’° ACCOUNT STATUS                                 â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Metric                                      â•‘ Value                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Balance                                     â•‘ $", DoubleToString(balance, 2), " ğŸ¦                  â•‘");
    Print("â•‘ Equity                                      â•‘ $", DoubleToString(equity, 2), " ğŸ’µ                  â•‘");
    Print("â•‘ Floating P/L                                â•‘ $", DoubleToString(floating, 2), " ", (floating >= 0 ? "âœ…" : "âŒ"), "                    â•‘");
    Print("â•‘ Used Margin                                 â•‘ $", DoubleToString(margin, 2), " ğŸ“Š                     â•‘");
    Print("â•‘ Free Margin                                 â•‘ $", DoubleToString(freeMargin, 2), " ğŸ“Š                  â•‘");
    
    string marginStatus = "SAFE ğŸŸ¢";
    if(marginLevel < 100) marginStatus = "WARNING ğŸŸ¡";
    if(marginLevel < 50) marginStatus = "DANGER ğŸ”´";
    if(marginLevel < 10) marginStatus = "CRITICAL ğŸ’€";
    
    Print("â•‘ Margin Level                                â•‘ ", DoubleToString(marginLevel, 1), "% ", marginStatus, "             â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

//+------------------------------------------------------------------+
//| ğŸ¯ STRATEGY PERFORMANCE MATRIX                                  |
//+------------------------------------------------------------------+
void LogStrategyPerformance()
{
    if(!EnableEnhancedLogging) return;
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          ğŸ¯ STRATEGY PERFORMANCE                             â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Metric                                      â•‘ Value                          â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Current Series                              â•‘ ", seriesActive ? (currentSeriesDirection == POSITION_TYPE_BUY ? "BUY ğŸŸ¢" : "SELL ğŸ”´") : "NONE â¸ï¸", "                         â•‘");
    Print("â•‘ Buy Sequence                                â•‘ ", buyMartingaleSequence, " ğŸŸ¢                            â•‘");
    Print("â•‘ Sell Sequence                               â•‘ ", sellMartingaleSequence, " ğŸ”´                            â•‘");
    Print("â•‘ Total Realized Profit                       â•‘ $", DoubleToString(cumulativeRealizedProfit, 2), " ğŸ’°                        â•‘");
    Print("â•‘ Safe Overlap Closures                       â•‘ ", overlapClosuresCount, " ğŸ”„                            â•‘");
    Print("â•‘ Total Overlap Profit                        â•‘ $", DoubleToString(totalOverlapProfit, 2), " ğŸ’                        â•‘");
    Print("â•‘ Trading Allowed                             â•‘ ", IsTradingAllowed() ? "YES âœ…" : "NO âŒ", "                          â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

//+------------------------------------------------------------------+
//| ğŸ“ˆ MARTINGALE PROGRESS MATRIX                                   |
//+------------------------------------------------------------------+
void LogMartingaleProgress(ENUM_POSITION_TYPE type, int sequence, double currentLot, double nextLot, double distance)
{
    if(!EnableEnhancedLogging) return;
    
    string direction = (type == POSITION_TYPE_BUY) ? "BUY ğŸŸ¢" : "SELL ğŸ”´";
    string status = (sequence == 0) ? "FIRST TRADE ğŸ¯" : "MARTINGALE â™Ÿï¸";
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          â™Ÿï¸ MARTINGALE PROGRESSION                           â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                    â•‘ Value                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Direction                                    â•‘ ", direction, "                     â•‘");
    Print("â•‘ Status                                       â•‘ ", status, "              â•‘");
    Print("â•‘ Current Sequence                             â•‘ ", sequence, " ğŸ”¢                 â•‘");
    Print("â•‘ Current Lot                                  â•‘ ", DoubleToString(currentLot, 2), " ğŸ“¦              â•‘");
    Print("â•‘ Next Lot                                     â•‘ ", DoubleToString(nextLot, 2), " â¡ï¸              â•‘");
    Print("â•‘ Required Distance                            â•‘ ", DoubleToString(distance, 1), " pips ğŸ“        â•‘");
    Print("â•‘ Check Time                                   â•‘ ", TimeToString(TimeCurrent(), TIME_SECONDS), "        â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

//+------------------------------------------------------------------+
//| ğŸ›¡ï¸ RISK MANAGEMENT MATRIX                                       |
//+------------------------------------------------------------------+
void LogRiskManagementEvent(string eventType, string details, double value = 0)
{
    if(!EnableEnhancedLogging) return;
    
    string emoji = "ğŸ›¡ï¸";
    if(StringFind(eventType, "PROFIT") >= 0) emoji = "ğŸ’°";
    if(StringFind(eventType, "LOSS") >= 0) emoji = "ğŸ’¸";
    if(StringFind(eventType, "WARNING") >= 0) emoji = "âš ï¸";
    if(StringFind(eventType, "ERROR") >= 0) emoji = "âŒ";
    
    Print("");
    Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    Print("â•‘                          ", emoji, " RISK MANAGEMENT                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Parameter                                    â•‘ Value                        â•‘");
    Print("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    Print("â•‘ Event Type                                   â•‘ ", eventType, "                   â•‘");
    Print("â•‘ Details                                      â•‘ ", details, "                   â•‘");
    if(value != 0) Print("â•‘ Value                         â•‘ ", DoubleToString(value, 2), "                 â•‘");
    Print("â•‘ Time                                         â•‘ ", TimeToString(TimeCurrent(), TIME_SECONDS), "        â•‘");
    Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
}

//+------------------------------------------------------------------+
//| â± PERIODIC STATUS - MASTER DASHBOARD                            |
//+------------------------------------------------------------------+
void LogPeriodicStatus()
{
    if(!EnableEnhancedLogging) return;
    
    static datetime lastStatusLog = 0;
    
    if(TimeCurrent() - lastStatusLog >= LogUpdateFrequency)
    {
        Print("");
        Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Print("â•‘                      ğŸ“ˆ ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½ - MASTER DASHBOARD                      â•‘");
        Print("â•‘                    ENHANCED POSITION MONITORING v3.16                        â•‘");
        Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        
        LogPositionDashboard();
        LogAccountStatus();
        LogStrategyPerformance();
        
        lastStatusLog = TimeCurrent();
        
        Print("");
        Print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        Print("â•‘                          âœ… DASHBOARD UPDATE COMPLETE                        â•‘");
        Print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Print("");
    }
}

//+==================================================================+
//| ğŸ”¤ğŸŸª CUSTOM STRING & NUMBER UTILITY FUNCTIONS                    |
//+==================================================================+

int StringToIntegerCustom(string text)
{
   int  result = 0;
   int  sign   = 1;
   int  start  = 0;

   if(StringLen(text) == 0)
      return 0;

   if(StringGetCharacter(text, 0) == '-')
   {
      sign  = -1;
      start = 1;
   }

   for(int i = start; i < StringLen(text); i++)
   {
      ushort ch = StringGetCharacter(text, i);

      if(ch >= '0' && ch <= '9')
         result = result * 10 + (ch - '0');
      else
         break;
   }

   return result * sign;
}

string StringSubstrCustom(string text, int start, int length = -1)
{
   if(length == -1)
      length = StringLen(text) - start;

   if(start < 0 || start >= StringLen(text) || length <= 0)
      return "";

   string result = "";

   for(int i = start; i < start + length && i < StringLen(text); i++)
      result += CharToString((uchar)StringGetCharacter(text, i));

   return result;
}

string DoubleToStringCustom(double value, int digits = 2)
{
   if(digits < 0) digits = 2;

   string result   = "";
   bool   negative = false;

   if(value < 0)
   {
      negative = true;
      value    = -value;
   }

   long   integerPart    = (long)value;
   double fractionalPart = value - integerPart;

   if(integerPart == 0)
      result = "0";
   else
   {
      string temp = "";
      while(integerPart > 0)
      {
         temp        = CharToString((uchar)('0' + (integerPart % 10))) + temp;
         integerPart /= 10;
      }
      result = temp;
   }

   if(digits > 0)
   {
      result += ".";
      for(int i = 0; i < digits; i++)
      {
         fractionalPart *= 10;
         int digit = (int)fractionalPart;
         result += CharToString((uchar)('0' + digit));
         fractionalPart -= digit;
      }
   }

   if(negative)
      result = "-" + result;

   return result;
}

//+==================================================================+
//| ğŸ’¹ğŸŸ¦ PROFIT / LOSS SYSTEM INITIALIZATION                           |
//+==================================================================+

void InitializeProfitLossSystem()
{
   if(EnableProfitLossDisplay != TRUE) return;

   closedTradesCount = 0;
   ArrayResize(closedTradesArray, 0);
   sessionStartTime = TimeCurrent();
   CleanupAllProfitObjects();

   Print("ğŸ’° Profit/Loss Chart Display Initialized - HISTORY DISABLED");
   Print("âœ¨ Only PROFIT trades closed during this session will be displayed");
}

bool SafeArrayResize(ClosedTradeInfo &array[], int newSize)
{
   if(newSize < 0) return false;
   int result = ArrayResize(array, newSize);

   if(result < 0)
   {
      Print("âš ï¸ Error resizing array to size ", newSize, ". Error code: ", GetLastError());
      return false;
   }

   return true;
}

void CheckNewClosedTrades()
{
   if(EnableProfitLossDisplay != TRUE) return;

   int previousCount  = closedTradesCount;
   int newTradesFound = 0;

   HistorySelect(sessionStartTime, TimeCurrent());
   int totalDeals = HistoryDealsTotal();

   for(int i = 0; i < totalDeals; i++)
   {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0) continue;

      if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;

      string symbol = HistoryDealGetString(ticket, DEAL_SYMBOL);
      long   magic  = HistoryDealGetInteger(ticket, DEAL_MAGIC);

      if(symbol != _Symbol) continue;
      if(!(magic == Magic || (ManualHandOrder && magic == 0))) continue;

      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT) +
                      HistoryDealGetDouble(ticket, DEAL_COMMISSION) +
                      HistoryDealGetDouble(ticket, DEAL_SWAP);

      if(profit <= 0) continue;

      bool alreadyExists = false;
      for(int j = 0; j < closedTradesCount; j++)
      {
         if(closedTradesArray[j].ticket == ticket) { alreadyExists = true; break; }
      }
      if(alreadyExists) continue;

      if(ArrayResize(closedTradesArray, closedTradesCount + 1) < 0)
      {
         Print("âš ï¸ Failed to resize closedTradesArray");
         continue;
      }

      closedTradesArray[closedTradesCount].ticket     = ticket;
      closedTradesArray[closedTradesCount].closeTime  = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
      closedTradesArray[closedTradesCount].profit     = profit;
      closedTradesArray[closedTradesCount].closePrice = HistoryDealGetDouble(ticket, DEAL_PRICE);
      closedTradesArray[closedTradesCount].type       = (HistoryDealGetInteger(ticket, DEAL_TYPE) == DEAL_TYPE_BUY) ? POSITION_TYPE_BUY : POSITION_TYPE_SELL;

      CreateProfitLossTextObject(
         closedTradesArray[closedTradesCount].ticket,
         closedTradesArray[closedTradesCount].closeTime,
         closedTradesArray[closedTradesCount].profit,
         closedTradesArray[closedTradesCount].closePrice,
         closedTradesArray[closedTradesCount].type
      );

      closedTradesCount++;
      newTradesFound++;

      Print("ğŸ’° PROFIT Trade displayed: Ticket ", ticket, " Profit: ", closedTradesArray[closedTradesCount - 1].profit);
   }

   if(newTradesFound > 0)
      Print("ğŸŒŸ Added ", newTradesFound, " PROFIT trades for display (current session only)");
}

void CreateProfitLossTextObject(ulong ticket, datetime closeTime, double profit, double closePrice, ENUM_POSITION_TYPE type)
{
   if (EnableProfitLossDisplay != TRUE || profit <= 0) return;

   string objName = "Profit_" + IntegerToString(ticket);

   if (ObjectFind(0, objName) >= 0) ObjectDelete(0, objName);

   int barIndex     = iBarShift(_Symbol, PERIOD_CURRENT, closeTime);
   double yPosition = closePrice;

   if(barIndex >= 0 && barIndex < Bars(_Symbol, PERIOD_CURRENT))
   {
      double candleHigh = iHigh(_Symbol, PERIOD_CURRENT, barIndex);
      double candleLow  = iLow(_Symbol, PERIOD_CURRENT, barIndex);

      yPosition = (type == POSITION_TYPE_BUY) ? 
                   candleHigh + (PointsToPrice(TextOffset)) : 
                   candleLow  - (PointsToPrice(TextOffset));
   }
   else
   {
      yPosition = (type == POSITION_TYPE_BUY) ? closePrice + (PointsToPrice(TextOffset)) : closePrice - (PointsToPrice(TextOffset));
   }

   double xPosition = (double)closeTime;

   if(ObjectCreate(0, objName, OBJ_TEXT, 0, (datetime)xPosition, yPosition))
   {
      string profitText = FormatProfitText(profit);

      ObjectSetString(0,  objName, OBJPROP_TEXT,      profitText);
      ObjectSetInteger(0, objName, OBJPROP_COLOR,     ProfitColor);
      ObjectSetInteger(0, objName, OBJPROP_FONTSIZE,  FontSize);
      ObjectSetString(0,  objName, OBJPROP_FONT,      FontFace);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR,    ANCHOR_LEFT);
      ObjectSetInteger(0, objName, OBJPROP_BACK,      false);
      ObjectSetInteger(0, objName, OBJPROP_SELECTABLE,false);
      ObjectSetInteger(0, objName, OBJPROP_HIDDEN,    false);
      ObjectSetInteger(0, objName, OBJPROP_ZORDER,    1000);

      string bgName = objName + "_BG";
      if(ObjectFind(0, bgName) >= 0) ObjectDelete(0, bgName);

      if(ObjectCreate(0, bgName, OBJ_RECTANGLE_LABEL, 0, 0, 0))
      {
         int textWidth  = StringLen(profitText) * (FontSize - 2);
         int textHeight = FontSize + 4;

         ObjectSetInteger(0, bgName, OBJPROP_XDISTANCE,  5);
         ObjectSetInteger(0, bgName, OBJPROP_YDISTANCE,  2);
         ObjectSetInteger(0, bgName, OBJPROP_XSIZE,      textWidth);
         ObjectSetInteger(0, bgName, OBJPROP_YSIZE,      textHeight);
         ObjectSetInteger(0, bgName, OBJPROP_BGCOLOR,    clrBlack);
         ObjectSetInteger(0, bgName, OBJPROP_BORDER_COLOR, clrGray);
         ObjectSetInteger(0, bgName, OBJPROP_BACK,       true);
         ObjectSetInteger(0, bgName, OBJPROP_SELECTABLE, false);
         ObjectSetInteger(0, bgName, OBJPROP_HIDDEN,     false);
         ObjectSetInteger(0, bgName, OBJPROP_ZORDER,     999);
      }

      if(EnableDebugLog)
         Print("ğŸ’¹ğŸ’– Created PROFIT text: ", profitText, " Ticket ", ticket, " at ", TimeToString(closeTime), " Price: ", yPosition);
   }
   else
   {
      Print("âš ï¸ Error creating profit text object for ticket: ", ticket, " Error: ", GetLastError());
   }
}

string FormatProfitText(double profit)
{
   string currency = AccountInfoString(ACCOUNT_CURRENCY);
   return StringFormat("ğŸ’– +%.2f %s ğŸ’¹âœ¨ğŸš€", profit, currency);
}

void UpdateProfitLossDisplay()
{
   if (EnableProfitLossDisplay != TRUE) return;

   static datetime lastHistoryCheck = 0;

   if (TimeCurrent() - lastHistoryCheck >= 2)
   {
      CheckNewClosedTrades();
      lastHistoryCheck = TimeCurrent();
   }

   CleanupOldProfitObjects();
   RefreshProfitObjects();
}

void RefreshProfitObjects()
{
   if (EnableProfitLossDisplay != TRUE) return;

   static datetime lastRefresh = 0;

   if (TimeCurrent() - lastRefresh < 5) return;

   lastRefresh = TimeCurrent();
   datetime recentTime = TimeCurrent() - 3600;

   for (int i = 0; i < closedTradesCount; i++)
   {
      if (closedTradesArray[i].closeTime >= recentTime)
      {
         string objName = "Profit_" + IntegerToString(closedTradesArray[i].ticket);

         if (ObjectFind(0, objName) < 0)
         {
            CreateProfitLossTextObject(
               closedTradesArray[i].ticket, 
               closedTradesArray[i].closeTime, 
               closedTradesArray[i].profit, 
               closedTradesArray[i].closePrice, 
               closedTradesArray[i].type
            );
         }
         else
         {
            ObjectSetInteger(0, objName, OBJPROP_COLOR,    ProfitColor);
            ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, FontSize);
            ObjectSetString(0,  objName, OBJPROP_FONT,    FontFace);
         }
      }
   }
}

//+==================================================================+
//| ğŸ’¹ğŸŸ© PROFIT OBJECT CLEANUP & LAST ACTION DISPLAY SYSTEM          |
//+==================================================================+

void CleanupOldProfitObjects()
{
   if(EnableProfitLossDisplay != TRUE) return;

   static datetime lastCleanup = 0;
   if(TimeCurrent() - lastCleanup < 10) return;

   lastCleanup = TimeCurrent();
   
   int totalObjects     = ObjectsTotal(0, 0, -1);
   datetime oldestAllowed = iTime(_Symbol, PERIOD_CURRENT, 500);

   for(int i = totalObjects - 1; i >= 0; i--)
   {
      string objName = ObjectName(0, i, 0, -1);

      if(StringFind(objName, "Profit_") == 0)
      {
         datetime objTime = (datetime)ObjectGetInteger(0, objName, OBJPROP_TIME);

         if(objTime < oldestAllowed)
         {
            ObjectDelete(0, objName);

            string bgName = objName + "_BG";
            if(ObjectFind(0, bgName) >= 0) ObjectDelete(0, bgName);

            if(EnableDebugLog)
               Print("ğŸ§¹ Removed old profit object: ", objName);
         }
      }
   }
}

void CleanupAllProfitObjects()
{
   if(EnableProfitLossDisplay != TRUE) return;

   int totalObjects = ObjectsTotal(0, 0, -1);

   for(int i = totalObjects - 1; i >= 0; i--)
   {
      string objName = ObjectName(0, i, 0, -1);

      if(StringFind(objName, "Profit_") == 0)
      {
         ObjectDelete(0, objName);

         string bgName = objName + "_BG";
         if(ObjectFind(0, bgName) >= 0) ObjectDelete(0, bgName);
      }
   }

   Print("ğŸ§¹ğŸ’– Cleaned all profit/loss objects from chart history ğŸ’Œ");
}

//+------------------------------------------------------------------+
//| ğŸŒŸğŸ’– PROFESSIONAL LAST ACTION DISPLAY - PROFIT ONLY VERSION â¤ï¸    |
//+------------------------------------------------------------------+

void ShowLastAction(double profitValue = 0)
{
   if(profitValue <= 0)
   {
      lastActionVisible = false;
      ObjectDelete(0, "LastActionPanel");
      ObjectDelete(0, "LastActionText");
      ObjectDelete(0, "LastActionShadow");
      return;
   }

   string actionType      = "Profit";
   lastActionText         = StringFormat("Last Action: %s +$%.2f", actionType, profitValue);
   lastActionProfit       = profitValue;
   lastActionColor        = clrLime;
   lastActionVisible      = true;
   lastActionTime         = TimeCurrent();

   Print("ğŸŒŸ LAST ACTION (PROFIT): ", lastActionText);

   UpdateLastActionDisplay();
}

void UpdateLastActionDisplay()
{
   if(!lastActionVisible)
   {
      ObjectDelete(0, "LastActionPanel");
      ObjectDelete(0, "LastActionText");
      ObjectDelete(0, "LastActionShadow");
      return;
   }

   int panelWidth   = 240;
   int panelHeight  = 30;
   int marginRight  = 300;
   int marginTop    = 20;

   if(ObjectFind(0, "LastActionShadow") < 0) ObjectCreate(0, "LastActionShadow", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_XDISTANCE, marginRight + 2);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_YDISTANCE, marginTop + 2);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_XSIZE, panelWidth);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_YSIZE, panelHeight);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_BGCOLOR, clrGray);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_BACK, true);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_HIDDEN, false);
   ObjectSetInteger(0, "LastActionShadow", OBJPROP_ZORDER, 0);

   if(ObjectFind(0, "LastActionPanel") < 0) ObjectCreate(0, "LastActionPanel", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_XDISTANCE, marginRight);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_YDISTANCE, marginTop);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_XSIZE, panelWidth);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_YSIZE, panelHeight);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_BGCOLOR, clrDarkGreen);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_BORDER_COLOR, clrLime);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_BACK, false);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_HIDDEN, false);
   ObjectSetInteger(0, "LastActionPanel", OBJPROP_ZORDER, 1);

   if(ObjectFind(0, "LastActionText") < 0) ObjectCreate(0, "LastActionText", OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "LastActionText", OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0, "LastActionText", OBJPROP_XDISTANCE, marginRight + 10);
   ObjectSetInteger(0, "LastActionText", OBJPROP_YDISTANCE, marginTop + 10);
   ObjectSetInteger(0, "LastActionText", OBJPROP_SELECTABLE, false);
   ObjectSetInteger(0, "LastActionText", OBJPROP_HIDDEN, false);
   ObjectSetInteger(0, "LastActionText", OBJPROP_ZORDER, 2);
   ObjectSetInteger(0, "LastActionText", OBJPROP_ANCHOR, ANCHOR_LEFT);

   string indentedText = "   " + lastActionText;
   ObjectSetString(0, "LastActionText", OBJPROP_TEXT, indentedText);
   ObjectSetInteger(0, "LastActionText", OBJPROP_COLOR, lastActionColor);
   ObjectSetInteger(0, "LastActionText", OBJPROP_FONTSIZE, 11);
   ObjectSetString(0, "LastActionText", OBJPROP_FONT, "Arial Bold");
}

//+==================================================================+
//| âš¡ğŸ’ COMPLETE FIXED OVERLAP SYSTEM - FULLY FUNCTIONAL           |
//+==================================================================+

//------------------------------------------------------------------
// ğŸ¯ Unified Dollar Profit Calculator (Redirects to Correct Handler)
//------------------------------------------------------------------
double CalculateProfitInDollars(double priceDiff, double volume)
{
    return CalculateProfitInDollarsCorrect(priceDiff, volume);
}

//+------------------------------------------------------------------+
//| ğŸ’ FIND OLDEST & NEWEST MANAGED POSITIONS - FIXED              |
//+------------------------------------------------------------------+
bool FindOldestAndNewestTrades(ulong &oldestTicket, ulong &newestTicket)
{
    datetime oldestTime = D'3000.01.01 00:00';
    datetime newestTime = 0;

    oldestTicket = 0;
    newestTicket = 0;

    int total = PositionsTotal();
    if (total < 2) 
        return false;

    for (int i = 0; i < total; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if (ticket == 0 || !ShouldManagePosition(ticket))
            continue;

        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);

        if (openTime < oldestTime)
        {
            oldestTime   = openTime;
            oldestTicket = ticket;
        }

        if (openTime > newestTime)
        {
            newestTime   = openTime;
            newestTicket = ticket;
        }
    }

    return (oldestTicket != 0 && newestTicket != 0 && oldestTicket != newestTicket);
}

//+------------------------------------------------------------------+
//| ğŸ’ FIND ALL POSITIONS OF TYPE - FOR OVERLAP ANALYSIS           |
//+------------------------------------------------------------------+
int FindPositionsOfType(ENUM_POSITION_TYPE type, ulong &tickets[], datetime &openTimes[], double &lots[], double &openPrices[])
{
    ArrayResize(tickets, 0);
    ArrayResize(openTimes, 0);
    ArrayResize(lots, 0);
    ArrayResize(openPrices, 0);
    
    int count = 0;
    
    for (int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if (ticket == 0 || !ShouldManagePosition(ticket))
            continue;
            
        ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        if (posType != type)
            continue;
            
        // Add to arrays
        int size = ArraySize(tickets);
        ArrayResize(tickets, size + 1);
        ArrayResize(openTimes, size + 1);
        ArrayResize(lots, size + 1);
        ArrayResize(openPrices, size + 1);
        
        PositionSelectByTicket(ticket);
        tickets[size] = ticket;
        openTimes[size] = (datetime)PositionGetInteger(POSITION_TIME);
        lots[size] = PositionGetDouble(POSITION_VOLUME);
        openPrices[size] = PositionGetDouble(POSITION_PRICE_OPEN);
        
        count++;
    }
    
    // Sort by open time (oldest first)
    if (count > 1)
    {
        // Simple bubble sort for small arrays
        for (int i = 0; i < count - 1; i++)
        {
            for (int j = i + 1; j < count; j++)
            {
                if (openTimes[j] < openTimes[i])
                {
                    // Swap all arrays
                    datetime tempTime = openTimes[i];
                    openTimes[i] = openTimes[j];
                    openTimes[j] = tempTime;
                    
                    ulong tempTicket = tickets[i];
                    tickets[i] = tickets[j];
                    tickets[j] = tempTicket;
                    
                    double tempLot = lots[i];
                    lots[i] = lots[j];
                    lots[j] = tempLot;
                    
                    double tempPrice = openPrices[i];
                    openPrices[i] = openPrices[j];
                    openPrices[j] = tempPrice;
                }
            }
        }
    }
    
    return count;
}

//+------------------------------------------------------------------+
//| ğŸ’ CALCULATE POSITION PROFIT - FIXED                           |
//+------------------------------------------------------------------+
double CalculatePositionProfit(ulong ticket, double currentPrice)
{
    if(!PositionSelectByTicket(ticket)) 
        return 0.0;

    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double volume = PositionGetDouble(POSITION_VOLUME);

    double priceDiff = 0.0;
    if(type == POSITION_TYPE_BUY)
        priceDiff = (currentPrice - openPrice);
    else
        priceDiff = (openPrice - currentPrice);

    // Use correct profit calculation
    return CalculateProfitInDollarsCorrect(priceDiff, volume);
}



//+------------------------------------------------------------------+
//| ğŸ’ COUNT OPEN POSITIONS OF TYPE - OPTIMIZED                    |
//+------------------------------------------------------------------+
int CountOpenPositionsOfType(ENUM_POSITION_TYPE type)
{
    int count = 0;
    
    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && PositionSelectByTicket(ticket))
        {
            string symbol = PositionGetString(POSITION_SYMBOL);
            long positionMagic = PositionGetInteger(POSITION_MAGIC);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

            if(symbol == _Symbol && posType == type)
            {
                // Check if we should manage this position
                if(ManualHandOrder && positionMagic == 0) 
                    count++;
                else if(positionMagic == (long)Magic) 
                    count++;
            }
        }
    }
    
    return count;
}

//+------------------------------------------------------------------+
//| ğŸ’ FIND BEST OVERLAP CANDIDATES - FIXED                        |
//| Returns true if found profitable overlap to close               |
//+------------------------------------------------------------------+
bool FindBestOverlapCandidates(ENUM_POSITION_TYPE type, 
                               ulong &closeTicket1, ulong &closeTicket2,
                               double &netProfit)
{
    closeTicket1 = 0;
    closeTicket2 = 0;
    netProfit = 0.0;
    
    // Get all positions of this type
    ulong tickets[];
    datetime openTimes[];
    double lots[];
    double openPrices[];
    
    int count = FindPositionsOfType(type, tickets, openTimes, lots, openPrices);
    if (count < 2)
        return false;
    
    // Current prices
    double currentPrice = (type == POSITION_TYPE_BUY) ? 
                         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    // ğŸ¯ STRATEGY 1: Try oldest + newest (default overlap logic)
    ulong oldestTicket = tickets[0];
    ulong newestTicket = tickets[count - 1];
    
    double oldestProfit = CalculatePositionProfit(oldestTicket, currentPrice);
    double newestProfit = CalculatePositionProfit(newestTicket, currentPrice);
    double combinedProfit = oldestProfit + newestProfit;
    
    // Calculate points difference
    double oldestPoints = GetPositionProfitPoints(oldestTicket, currentPrice);
    double newestPoints = GetPositionProfitPoints(newestTicket, currentPrice);
    double pointsDiff = newestPoints - oldestPoints;
    
    if (combinedProfit >= OverlapMinNetProfit && 
        pointsDiff >= OverlapPointsDifference &&
        combinedProfit > 0)  // Must be net positive
    {
        closeTicket1 = oldestTicket;
        closeTicket2 = newestTicket;
        netProfit = combinedProfit;
        
        PrintFormat("ğŸ¯ Overlap Strategy 1 (Oldest+Newest): "
                   "Oldest=$%.2f (%.1f pts), Newest=$%.2f (%.1f pts), "
                   "Net=$%.2f, PointsDiff=%.1f",
                   oldestProfit, oldestPoints,
                   newestProfit, newestPoints,
                   netProfit, pointsDiff);
        return true;
    }
    
    // ğŸ¯ STRATEGY 2: Try to find any two positions that meet criteria
    // Look for oldest position that can be closed profitably with any newer position
    for (int i = 0; i < count - 1; i++)  // i = older position
    {
        ulong ticket1 = tickets[i];
        double profit1 = CalculatePositionProfit(ticket1, currentPrice);
        double points1 = GetPositionProfitPoints(ticket1, currentPrice);
        
        // Skip if older position is at a big loss (might indicate wrong direction)
        if (profit1 < -OverlapMinNetProfit)
            continue;
            
        for (int j = i + 1; j < count; j++)  // j = newer position
        {
            ulong ticket2 = tickets[j];
            double profit2 = CalculatePositionProfit(ticket2, currentPrice);
            double points2 = GetPositionProfitPoints(ticket2, currentPrice);
            
            combinedProfit = profit1 + profit2;
            pointsDiff = points2 - points1;
            
            // Check overlap conditions
            if (combinedProfit >= OverlapMinNetProfit && 
                pointsDiff >= OverlapPointsDifference &&
                combinedProfit > 0)
            {
                closeTicket1 = ticket1;
                closeTicket2 = ticket2;
                netProfit = combinedProfit;
                
                PrintFormat("ğŸ¯ Overlap Strategy 2 (Pair %d+%d): "
                           "Pos1=$%.2f (%.1f pts), Pos2=$%.2f (%.1f pts), "
                           "Net=$%.2f, PointsDiff=%.1f",
                           i, j, profit1, points1, profit2, points2,
                           netProfit, pointsDiff);
                return true;
            }
        }
    }
    
    // ğŸ¯ STRATEGY 3: If we have many positions, try closing multiple oldest ones
    if (count >= 3)
    {
        double totalProfit = 0;
        int positionsToClose = 0;
        
        // Try closing the 2 oldest positions
        for (int i = 0; i < MathMin(2, count); i++)
        {
            double profit = CalculatePositionProfit(tickets[i], currentPrice);
            totalProfit += profit;
            positionsToClose++;
        }
        
        if (totalProfit >= OverlapMinNetProfit && totalProfit > 0)
        {
            closeTicket1 = tickets[0];
            closeTicket2 = tickets[1];
            netProfit = totalProfit;
            
            PrintFormat("ğŸ¯ Overlap Strategy 3 (2 Oldest): Net=$%.2f", netProfit);
            return true;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| ğŸ’ MAIN OVERLAP CHECK FUNCTION - COMPLETELY FIXED              |
//+------------------------------------------------------------------+
void CheckSafeOverlapClosure()
{
    if (!EnableSafeOverlap)
        return;

    // Throttle checks
    static datetime lastCheck = 0;
    if (TimeCurrent() - lastCheck < OverlapCheckFrequency)
        return;
    lastCheck = TimeCurrent();

    // Check both directions
    bool overlapClosed = false;
    
    // ğŸŸ¢ CHECK BUY POSITIONS
    if (CountOpenPositionsOfType(POSITION_TYPE_BUY) >= 2)
    {
        ulong closeTicket1, closeTicket2;
        double netProfit;
        
        if (FindBestOverlapCandidates(POSITION_TYPE_BUY, closeTicket1, closeTicket2, netProfit))
        {
            if (ExecuteOverlapClosure(POSITION_TYPE_BUY, closeTicket1, closeTicket2, netProfit))
            {
                overlapClosed = true;
            }
        }
    }
    
    // ğŸ”´ CHECK SELL POSITIONS
    if (!overlapClosed && CountOpenPositionsOfType(POSITION_TYPE_SELL) >= 2)
    {
        ulong closeTicket1, closeTicket2;
        double netProfit;
        
        if (FindBestOverlapCandidates(POSITION_TYPE_SELL, closeTicket1, closeTicket2, netProfit))
        {
            if (ExecuteOverlapClosure(POSITION_TYPE_SELL, closeTicket1, closeTicket2, netProfit))
            {
                overlapClosed = true;
            }
        }
    }
    
    // Log if no overlap found (for debugging)
    if (!overlapClosed && EnableDebugLog)
    {
        static int noOverlapCounter = 0;
        noOverlapCounter++;
        if (noOverlapCounter % 10 == 0)  // Log every 10 checks
        {
            Print("No profitable overlap found. Conditions:");
            PrintFormat("  Min Net Profit: $%.2f", OverlapMinNetProfit);
            PrintFormat("  Min Points Diff: %d", OverlapPointsDifference);
            
            // Show current positions status
            for (int i = 0; i < PositionsTotal(); i++)
            {
                ulong ticket = PositionGetTicket(i);
                if (ticket == 0 || !ShouldManagePosition(ticket))
                    continue;
                    
                PositionSelectByTicket(ticket);
                ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                double volume = PositionGetDouble(POSITION_VOLUME);
                double currentPrice = (type == POSITION_TYPE_BUY) ? 
                                     SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                                     SymbolInfoDouble(_Symbol, SYMBOL_ASK);
                double profit = CalculatePositionProfit(ticket, currentPrice);
                double points = GetPositionProfitPoints(ticket, currentPrice);
                
                PrintFormat("  Pos %d: %s, Lot=%.3f, Open=%.5f, Profit=$%.2f (%.1f pts)",
                           i, EnumToString(type), volume, openPrice, profit, points);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| ğŸ’ EXECUTE OVERLAP CLOSURE - FIXED                             |
//+------------------------------------------------------------------+
bool ExecuteOverlapClosure(ENUM_POSITION_TYPE type, 
                          ulong ticket1, ulong ticket2, 
                          double expectedProfit)
{
    if (ticket1 == 0 || ticket2 == 0)
        return false;
    
    Print("==================================================================");
    Print("ğŸ’ EXECUTING OVERLAP CLOSURE ğŸ’");
    PrintFormat("Direction: %s", EnumToString(type));
    PrintFormat("Closing tickets: %I64d and %I64d", ticket1, ticket2);
    PrintFormat("Expected net profit: $%.2f", expectedProfit);
    Print("==================================================================");
    
    double actualProfit = 0;
    int closedCount = 0;
    
    // Get position details before closing
    PositionSelectByTicket(ticket1);
    double lot1 = PositionGetDouble(POSITION_VOLUME);
    double price1 = PositionGetDouble(POSITION_PRICE_OPEN);
    
    PositionSelectByTicket(ticket2);
    double lot2 = PositionGetDouble(POSITION_VOLUME);
    double price2 = PositionGetDouble(POSITION_PRICE_OPEN);
    
    PrintFormat("Position 1: Lot=%.3f, Open=%.5f", lot1, price1);
    PrintFormat("Position 2: Lot=%.3f, Open=%.5f", lot2, price2);
    
    // ğŸ¯ CLOSE POSITION 2 FIRST (usually newer/higher lot)
    if (EnhancedSafePositionClose(ticket2))
    {
        closedCount++;
        
        // Get actual profit after closure
        HistorySelect(TimeCurrent() - 60, TimeCurrent());
        int deals = HistoryDealsTotal();
        for (int i = deals - 1; i >= 0; i--)
        {
            ulong dealTicket = HistoryDealGetTicket(i);
            if (HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT &&
                HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
            {
                double dealProfit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT) +
                                   HistoryDealGetDouble(dealTicket, DEAL_COMMISSION) +
                                   HistoryDealGetDouble(dealTicket, DEAL_SWAP);
                if (MathAbs(dealProfit) > 0.01)  // Non-zero profit
                {
                    actualProfit += dealProfit;
                    break;
                }
            }
        }
        
        Sleep(100);  // Small delay between closures
        
        // ğŸ¯ CLOSE POSITION 1 (older position)
        if (EnhancedSafePositionClose(ticket1))
        {
            closedCount++;
            
            // Get profit for second closure
            HistorySelect(TimeCurrent() - 60, TimeCurrent());
            deals = HistoryDealsTotal();
            for (int i = deals - 1; i >= 0; i--)
            {
                ulong dealTicket = HistoryDealGetTicket(i);
                if (HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT &&
                    HistoryDealGetString(dealTicket, DEAL_SYMBOL) == _Symbol)
                {
                    double dealProfit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT) +
                                       HistoryDealGetDouble(dealTicket, DEAL_COMMISSION) +
                                       HistoryDealGetDouble(dealTicket, DEAL_SWAP);
                    if (MathAbs(dealProfit) > 0.01)  // Non-zero profit
                    {
                        actualProfit += dealProfit;
                        break;
                    }
                }
            }
        }
    }
    
    // Update statistics
    if (closedCount == 2)
    {
        overlapClosuresCount++;
        totalOverlapProfit += actualProfit;
        
        // Show result
        Print("==================================================================");
        Print("âœ… OVERLAP CLOSURE SUCCESSFUL");
        PrintFormat("Closed %d positions", closedCount);
        PrintFormat("Expected profit: $%.2f", expectedProfit);
        PrintFormat("Actual profit: $%.2f", actualProfit);
        PrintFormat("Total overlap closures: %d", overlapClosuresCount);
        PrintFormat("Total overlap profit: $%.2f", totalOverlapProfit);
        Print("==================================================================");
        
        // Update display
        ShowLastAction(actualProfit);
        
        // Recalculate martingale state
        positionsDirty = true;
        RecalculateMartingaleState();
        
        // Update first lot tracking for this direction
        UpdateFirstLotTrackingAfterOverlap(type);
        
        return true;
    }
    else
    {
        Print("âŒ OVERLAP CLOSURE FAILED - Only closed ", closedCount, " positions");
        return false;
    }
}

//+------------------------------------------------------------------+
//| ğŸ’ UPDATE FIRST LOT TRACKING AFTER OVERLAP - FIXED             |
//+------------------------------------------------------------------+
void UpdateFirstLotTrackingAfterOverlap(ENUM_POSITION_TYPE type)
{
    int remaining = CountOpenPositionsOfType(type);
    
    if (remaining == 0)
    {
        // No positions left of this type
        if (type == POSITION_TYPE_BUY)
        {
            firstBuyLotTicket = 0;
            initialBuyBaseLot = 0;
            buyMartingaleSequence = 0;
        }
        else
        {
            firstSellLotTicket = 0;
            initialSellBaseLot = 0;
            sellMartingaleSequence = 0;
        }
        
        PrintFormat("âœ… %s tracking reset - no positions remaining", EnumToString(type));
    }
    else
    {
        // Find new first position (oldest remaining)
        ulong newFirstTicket = 0;
        datetime earliestTime = LONG_MAX;
        
        for (int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if (ticket == 0 || !ShouldManagePosition(ticket))
                continue;
                
            PositionSelectByTicket(ticket);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if (posType != type)
                continue;
                
            datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
            if (openTime < earliestTime)
            {
                earliestTime = openTime;
                newFirstTicket = ticket;
            }
        }
        
        if (newFirstTicket > 0)
        {
            PositionSelectByTicket(newFirstTicket);
            double newBaseLot = PositionGetDouble(POSITION_VOLUME);
            
            if (type == POSITION_TYPE_BUY)
            {
                firstBuyLotTicket = newFirstTicket;
                initialBuyBaseLot = newBaseLot;
                buyMartingaleSequence = remaining;
                
                PrintFormat("âœ… Buy tracking updated: FirstTicket=%I64d, BaseLot=%.3f, Sequence=%d",
                          newFirstTicket, newBaseLot, remaining);
            }
            else
            {
                firstSellLotTicket = newFirstTicket;
                initialSellBaseLot = newBaseLot;
                sellMartingaleSequence = remaining;
                
                PrintFormat("âœ… Sell tracking updated: FirstTicket=%I64d, BaseLot=%.3f, Sequence=%d",
                          newFirstTicket, newBaseLot, remaining);
            }
        }
    }
    
    // Update series state
    if (CountOpenPositionsOfType(POSITION_TYPE_BUY) == 0 && 
        CountOpenPositionsOfType(POSITION_TYPE_SELL) == 0)
    {
        seriesActive = false;
        currentSeriesDirection = WRONG_VALUE;
        Print("âœ… Series reset - no positions remaining");
    }
}

//+------------------------------------------------------------------+
//| ğŸ’ PROFIT/LOSS EXIT FUNCTIONS ğŸ’–                                  |
//+------------------------------------------------------------------+
void CheckProfitLoss()
{
    if(!EnableProfitLossExit || tradingHalted) return;                 // ğŸ’” Disabled or halted ğŸ’Œ

    static datetime lastCheck = 0;                                      // ğŸ’– Last check ğŸ’Œ
    if(TimeCurrent() - lastCheck < 1) return;                           // ğŸŒ¸ Check frequency ğŸ’
    lastCheck = TimeCurrent();                                           // ğŸ’Œ Update timestamp ğŸ’–

    ResetDailyProfitLoss();                                              // ğŸŒ¹ Reset daily counters ğŸ’Œ

    double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);           // ğŸ’– Current equity ğŸ’Œ
    double netProfit     = currentEquity - dailyStartBalance;           // ğŸŒ¸ Net daily profit ğŸ’

    if(EnableDebugLog && TimeCurrent() % 10 == 0)                       // ğŸ’Œ Periodic debug ğŸ’–
    {
        PrintFormat("ğŸ’ Profit/Loss Check: Equity=$%.2f, DailyStart=$%.2f, NetProfit=$%.2f", 
                    currentEquity, dailyStartBalance, netProfit);
    }

    if(!profitTargetHit && netProfit >= ProfitTarget)                   // ğŸŒ¹ Profit target hit ğŸ’–
    {
        Print("ğŸ’–!!! PROFIT TARGET HIT - DAILY PROFIT LIMIT REACHED !!!");
        profitTargetHit = true;
        CreateProfitLimitText();                                        // ğŸ’Œ Show text ğŸ’

        if(CloseOnTarget)                                               // ğŸŒ¸ Close positions ğŸ’–
        {
            Print("ğŸ’ Closing all positions as per Profit Target setting...");
            ForceCloseAllPositions();
        }

        tradingHalted = true;                                           // ğŸ’Œ Halt trading â¤ï¸
        Print("ğŸ’– Trading halted - Profit Target reached");
    }

    if(!lossLimitHit && netProfit <= LossLimit)                          // ğŸŒ¹ Loss limit hit ğŸ’–
    {
        Print("ğŸ’–!!! LOSS LIMIT HIT - DAILY LOSS LIMIT REACHED !!!");
        lossLimitHit = true;
        CreateLossLimitText();                                          // ğŸ’Œ Show text ğŸ’

        if(CloseOnTarget)                                               // ğŸŒ¸ Close positions ğŸ’–
        {
            Print("ğŸ’ Closing all positions as per Loss Limit setting...");
            ForceCloseAllPositions();
        }

        tradingHalted = true;                                           // ğŸ’Œ Halt trading â¤ï¸
        Print("ğŸ’– Trading halted - Loss Limit reached");
    }
}

//+==================================================================+
//| ğŸŒ¹ğŸ’– SUPER-ALIGNED PROFIT LIMIT PANEL DISPLAY ğŸ’Œ                 |
//| ğŸŒ¸ Master-level aesthetics & readability with loving emojis ğŸ’   |
//+==================================================================+
void CreateProfitLimitText()
{
    // ğŸ’– Remove any previous objects to start fresh
    ObjectDelete(0, "ProfitLimitPanel");       // ğŸ’Œ Delete old panel
    ObjectDelete(0, "ProfitLimitText");        // ğŸ’Œ Delete old text
    ObjectDelete(0, "ProfitLimitShadow");      // ğŸ’Œ Delete old shadow

    // ğŸŒ¹ Panel dimensions & positioning
    int panelWidth  = 640;                     // ğŸ’– Width of panel
    int panelHeight = 60;                      // ğŸ’– Height of panel
    int xPos        = (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS)/2 - panelWidth/2;  // ğŸ’Œ Center X
    int yPos        = 100;                     // ğŸ’Œ Fixed Y position

    // ğŸŒ¸ Create shadow behind panel
    if(ObjectFind(0, "ProfitLimitShadow") < 0)
        ObjectCreate(0, "ProfitLimitShadow", OBJ_RECTANGLE_LABEL, 0, 0, 0); // ğŸ’– Shadow object

    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_XDISTANCE, xPos + 3);       // ğŸ’– Shadow X
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_YDISTANCE, yPos + 3);       // ğŸ’– Shadow Y
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_XSIZE, panelWidth);         // ğŸ’– Shadow width
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_YSIZE, panelHeight);        // ğŸ’– Shadow height
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_BGCOLOR, clrDarkGray);      // ğŸ’Œ Shadow color
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_BORDER_COLOR, clrDarkGray); // ğŸ’Œ Shadow border
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_BACK, true);                // ğŸ’– Behind chart
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_SELECTABLE, false);         // ğŸ’– Not selectable
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_HIDDEN, false);             // ğŸ’– Visible
    ObjectSetInteger(0, "ProfitLimitShadow", OBJPROP_ZORDER, 0);                 // ğŸ’– Base layer

    // ğŸŒ¸ Create main panel
    if(ObjectFind(0, "ProfitLimitPanel") < 0)
        ObjectCreate(0, "ProfitLimitPanel", OBJ_RECTANGLE_LABEL, 0, 0, 0);      // ğŸ’– Panel object

    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_XDISTANCE, xPos);            // ğŸ’– Panel X
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_YDISTANCE, yPos);            // ğŸ’– Panel Y
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_XSIZE, panelWidth);          // ğŸ’– Panel width
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_YSIZE, panelHeight);         // ğŸ’– Panel height
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BGCOLOR, clrDarkGreen);      // ğŸ’Œ Background color
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BORDER_COLOR, clrLime);      // ğŸ’Œ Border color
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BORDER_TYPE, BORDER_FLAT);   // ğŸ’– Flat border
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BACK, false);                // ğŸ’– Front layer
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_SELECTABLE, false);          // ğŸ’– Not selectable
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_HIDDEN, false);              // ğŸ’– Visible
    ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_ZORDER, 1);                  // ğŸ’– Layer above shadow

    // ğŸŒ¸ Create text label
    if(ObjectFind(0, "ProfitLimitText") < 0)
        ObjectCreate(0, "ProfitLimitText", OBJ_LABEL, 0, 0, 0);                 // ğŸ’– Text object

    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_XDISTANCE, xPos + 10);        // ğŸ’– Text X
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_YDISTANCE, yPos + 20);        // ğŸ’– Text Y
    ObjectSetString(0,  "ProfitLimitText", OBJPROP_TEXT, "ğŸ‘‘ DAILY PROFIT LIMIT ğŸ¯ HIT - CONGRATULATIONS! ğŸ‘‘"); // ğŸ’Œ Message
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_COLOR, clrGold);              // ğŸ’– Text color
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_FONTSIZE, 14);                // ğŸ’– Font size
    ObjectSetString(0,  "ProfitLimitText", OBJPROP_FONT, "Arial Bold");          // ğŸ’– Font
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_SELECTABLE, false);           // ğŸ’– Not selectable
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_HIDDEN, false);               // ğŸ’– Visible
    ObjectSetInteger(0, "ProfitLimitText", OBJPROP_ZORDER, 2);                   // ğŸ’– Layer above panel

    // ğŸ’– Logging to Experts tab
    Print("=== PROFIT TARGET ACHIEVED ===");
    Print("ğŸ¯ Daily Profit Limit: $", DoubleToStringCustom(ProfitTarget, 2));
    Print("ğŸ’° Current Net Profit: $", DoubleToStringCustom(AccountInfoDouble(ACCOUNT_EQUITY) - dailyStartBalance, 2));
    Print("ğŸ‘‘ CONGRATULATIONS! Trading halted for today.");
    Print("==============================");

    // ğŸŒ¸ Initialize flicker effect
    lastFlickerUpdate = TimeCurrent(); // ğŸ’– Set flicker timestamp
    flickerState      = true;          // ğŸ’– Initial flicker state
}

//+==================================================================+
//| ğŸŒ¹ğŸ’– SUPER-ALIGNED LOSS LIMIT PANEL DISPLAY ğŸ’Œ                    |
//| ğŸŒ¸ Master-level aesthetics & readability with loving emojis ğŸ’   |
//+==================================================================+
void CreateLossLimitText()
{
    // ğŸ’– Delete any existing objects for fresh start
    ObjectDelete(0, "LossLimitPanel");      // ğŸ’Œ Remove old panel
    ObjectDelete(0, "LossLimitText");       // ğŸ’Œ Remove old text
    ObjectDelete(0, "LossLimitShadow");     // ğŸ’Œ Remove old shadow

    // ğŸŒ¹ Panel dimensions & positioning
    int panelWidth  = 735;                  // ğŸ’– Panel width
    int panelHeight = 60;                   // ğŸ’– Panel height
    int xPos        = (int)ChartGetInteger(0, CHART_WIDTH_IN_PIXELS)/2 - panelWidth/2;  // ğŸ’Œ Center X
    int yPos        = 100;                  // ğŸ’Œ Fixed Y

    // ğŸŒ¸ Create shadow behind panel
    if(ObjectFind(0, "LossLimitShadow") < 0)
        ObjectCreate(0, "LossLimitShadow", OBJ_RECTANGLE_LABEL, 0, 0, 0); // ğŸ’– Shadow object

    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_XDISTANCE, xPos + 3);       // ğŸ’– Shadow X
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_YDISTANCE, yPos + 3);       // ğŸ’– Shadow Y
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_XSIZE, panelWidth);         // ğŸ’– Shadow width
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_YSIZE, panelHeight);        // ğŸ’– Shadow height
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_BGCOLOR, clrDarkGray);      // ğŸ’Œ Shadow color
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_BORDER_COLOR, clrDarkGray); // ğŸ’Œ Shadow border
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_BACK, true);                // ğŸ’– Behind chart
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_SELECTABLE, false);         // ğŸ’– Not selectable
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_HIDDEN, false);             // ğŸ’– Visible
    ObjectSetInteger(0, "LossLimitShadow", OBJPROP_ZORDER, 0);                 // ğŸ’– Base layer

    // ğŸŒ¸ Create main panel
    if(ObjectFind(0, "LossLimitPanel") < 0)
        ObjectCreate(0, "LossLimitPanel", OBJ_RECTANGLE_LABEL, 0, 0, 0);      // ğŸ’– Panel object

    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_XDISTANCE, xPos);            // ğŸ’– Panel X
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_YDISTANCE, yPos);            // ğŸ’– Panel Y
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_XSIZE, panelWidth);          // ğŸ’– Panel width
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_YSIZE, panelHeight);         // ğŸ’– Panel height
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BGCOLOR, clrDarkRed);        // ğŸ’Œ Background color
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BORDER_COLOR, clrRed);       // ğŸ’Œ Border color
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BORDER_TYPE, BORDER_FLAT);   // ğŸ’– Flat border
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BACK, false);                // ğŸ’– Front layer
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_SELECTABLE, false);          // ğŸ’– Not selectable
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_HIDDEN, false);              // ğŸ’– Visible
    ObjectSetInteger(0, "LossLimitPanel", OBJPROP_ZORDER, 1);                  // ğŸ’– Layer above shadow

    // ğŸŒ¸ Create text label
    if(ObjectFind(0, "LossLimitText") < 0)
        ObjectCreate(0, "LossLimitText", OBJ_LABEL, 0, 0, 0);                 // ğŸ’– Text object

    ObjectSetInteger(0, "LossLimitText", OBJPROP_XDISTANCE, xPos + 10);        // ğŸ’– Text X
    ObjectSetInteger(0, "LossLimitText", OBJPROP_YDISTANCE, yPos + 20);        // ğŸ’– Text Y
    ObjectSetString(0, "LossLimitText", OBJPROP_TEXT, "ğŸ”’ğŸ’µ RISK CONTROL: DAILY LOSS LIMIT TRIGGERED â€” TRADING LOCKED");
    ObjectSetInteger(0, "LossLimitText", OBJPROP_COLOR, clrWhite);             // ğŸ’– Text color
    ObjectSetInteger(0, "LossLimitText", OBJPROP_FONTSIZE, 12);                // ğŸ’– Font size
    ObjectSetString(0,  "LossLimitText", OBJPROP_FONT, "Arial Bold");          // ğŸ’– Font
    ObjectSetInteger(0, "LossLimitText", OBJPROP_SELECTABLE, false);           // ğŸ’– Not selectable
    ObjectSetInteger(0, "LossLimitText", OBJPROP_HIDDEN, false);               // ğŸ’– Visible
    ObjectSetInteger(0, "LossLimitText", OBJPROP_ZORDER, 2);                   // ğŸ’– Layer above panel

    // ğŸ’– Logging to Experts tab
    Print("=== LOSS LIMIT TRIGGERED ===");
    Print("âš ï¸ Daily Loss Limit: $", DoubleToStringCustom(LossLimit, 2));
    Print("ğŸ’¸ Current Net Loss: $", DoubleToStringCustom(AccountInfoDouble(ACCOUNT_EQUITY) - dailyStartBalance, 2));
    Print("ğŸ›‘ Trading halted for today.");
    Print("============================");

    // ğŸŒ¸ Initialize flicker effect
    lastFlickerUpdate = TimeCurrent(); // ğŸ’– Set flicker timestamp
    flickerState      = true;          // ğŸ’– Initial flicker state
}

//+==================================================================+
//| ğŸŒ¹ğŸ’– FLICKER EFFECT UPDATE FUNCTION ğŸ’Œ                             |
//+==================================================================+
void UpdateFlickerEffect()
{
    // ğŸ’– Skip if no profit/loss limit hit
    if(!profitTargetHit && !lossLimitHit) return;

    static datetime lastFlicker = 0;                 // ğŸ’Œ Last flicker timestamp
    if(TimeCurrent() - lastFlicker < 0.5) return;    // ğŸ’– Flicker interval
    lastFlicker = TimeCurrent();                     // ğŸ’– Update timestamp
    flickerState = !flickerState;                   // ğŸ’– Toggle state

    // ğŸŒ¸ Profit target panel flicker
    if(profitTargetHit && ObjectFind(0, "ProfitLimitPanel") >= 0)
    {
        if(flickerState)
        {
            ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BGCOLOR, clrDarkGreen);
            ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BORDER_COLOR, clrLime);
            ObjectSetInteger(0, "ProfitLimitText", OBJPROP_COLOR, clrGold);
        }
        else
        {
            ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BGCOLOR, clrGreen);
            ObjectSetInteger(0, "ProfitLimitPanel", OBJPROP_BORDER_COLOR, clrYellow);
            ObjectSetInteger(0, "ProfitLimitText", OBJPROP_COLOR, clrWhite);
        }
    }

    // ğŸŒ¸ Loss limit panel flicker
    if(lossLimitHit && ObjectFind(0, "LossLimitPanel") >= 0)
    {
        if(flickerState)
        {
            ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BGCOLOR, clrDarkRed);
            ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BORDER_COLOR, clrRed);
            ObjectSetInteger(0, "LossLimitText", OBJPROP_COLOR, clrWhite);
        }
        else
        {
            ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BGCOLOR, clrMaroon);
            ObjectSetInteger(0, "LossLimitPanel", OBJPROP_BORDER_COLOR, clrOrange);
            ObjectSetInteger(0, "LossLimitText", OBJPROP_COLOR, clrYellow);
        }
    }
}

//+==================================================================+
//| ğŸŒ¹ğŸ’– DAILY PROFIT/LOSS RESET FUNCTION ğŸ’Œ                           |
//+==================================================================+
void ResetDailyProfitLoss()
{
    MqlDateTime today, lastReset;                  // ğŸ’Œ Structures for date comparison
    TimeToStruct(TimeCurrent(), today);           // ğŸ’– Current date
    TimeToStruct(lastDailyReset, lastReset);      // ğŸ’– Last reset date

    // ğŸ’– Initialize on first run
    if(lastDailyReset == 0)
    {
        dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE); // ğŸ’Œ Capture start balance
        lastDailyReset = TimeCurrent();                         // ğŸ’– Set timestamp
        Print("Daily Profit/Loss tracking started. Start Balance: $", DoubleToStringCustom(dailyStartBalance, 2));
        return;
    }

    // ğŸ’– Reset at start of new day
    if(today.day != lastReset.day || today.mon != lastReset.mon || today.year != lastReset.year)
    {
        Print("=== NEW DAY DETECTED - RESETTING DAILY PROFIT/LOSS TARGETS ===");

        profitTargetHit = false;                        // ğŸ’– Reset flags
        lossLimitHit   = false;
        tradingHalted   = false;
        dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE); // ğŸ’Œ New day start balance
        lastDailyReset = TimeCurrent();                          // ğŸ’– Timestamp

        // ğŸ’Œ Delete all old panel/text objects
        ObjectDelete(0, "ProfitLimitPanel");
        ObjectDelete(0, "ProfitLimitText");
        ObjectDelete(0, "ProfitLimitShadow");
        ObjectDelete(0, "LossLimitPanel");
        ObjectDelete(0, "LossLimitText");
        ObjectDelete(0, "LossLimitShadow");

        // ğŸ’– Logging
        Print("Daily targets reset. New Start Balance: $", DoubleToStringCustom(dailyStartBalance, 2));
        Print("Profit Target: $", DoubleToStringCustom(ProfitTarget, 2));
        Print("Loss Limit: $", DoubleToStringCustom(LossLimit, 2));
        Print("=============================================");
    }
}

void CleanupProfitLossMessages()
{
    ObjectDelete(0, "ProfitLimitPanel");
    ObjectDelete(0, "ProfitLimitText");
    ObjectDelete(0, "ProfitLimitShadow");
    ObjectDelete(0, "LossLimitPanel");
    ObjectDelete(0, "LossLimitText");
    ObjectDelete(0, "LossLimitShadow");

    if(EnableDebugLog)
        Print("ğŸ§¹ğŸ’– CleanupProfitLossMessages executed - All Profit/Loss messages removed ğŸ‡µğŸ‡°");
}

//+------------------------------------------------------------------+
//| ğŸ› ï¸ POSITION MANAGEMENT FUNCTIONS                               |
//+------------------------------------------------------------------+
void ForceCloseAllPositions()
{
    int totalPositions = PositionsTotal();
    if(totalPositions == 0)
    {
        Print("No positions to close. âœ…");
        return;
    }

    Print("âš¡ Force closing ", totalPositions, " positions...");

    int closedCount = 0;
    int maxAttempts = 5;
    double totalProfit = 0;

    for(int attempt = 0; attempt < maxAttempts && PositionsTotal() > 0; attempt++)
    {
        for(int i = PositionsTotal()-1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(ticket > 0 && ShouldManagePosition(ticket))
            {
                if(PositionSelectByTicket(ticket))
                {
                    double profit = PositionGetDouble(POSITION_PROFIT);
                    double volume = PositionGetDouble(POSITION_VOLUME);
                    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                    
                    PrintFormat("Closing position #%d: Ticket=%I64d, Type=%s, Volume=%.2f, Profit=$%.2f",
                                closedCount+1, ticket, EnumToString(type), volume, profit);
                    
                    if(EnhancedSafePositionClose(ticket))
                    {
                        closedCount++;
                        totalProfit += profit;
                        Print("âœ… Successfully closed position: ", ticket);
                    }
                    else
                    {
                        Print("âš ï¸ Failed to close position: ", ticket, " - Retrying...");
                    }
                }
            }
        }
        
        if(PositionsTotal() > 0)
        {
            Print("Remaining positions: ", PositionsTotal(), " - Retry attempt: ", attempt+1);
            Sleep(200);
        }
    }
    
    // FINAL CHECK: Force reset if chart is empty
    if(CountAllEAPositions() == 0)
    {
        Print("ğŸ¯ ForceCloseAllPositions: Chart is EMPTY - Immediate martingale reset!");
        ForceMartingaleResetImmediate();
    }
    
    if(closedCount > 0)
    {
        ShowLastAction(totalProfit);
        PrintFormat("âœ… Force closure completed. Total positions closed: %d, Total profit: $%.2f", 
                    closedCount, totalProfit);
    }
    else
    {
        Print("âš ï¸ WARNING: No positions were closed!");
    }
}

void CloseAllPositionsAlternative()
{
    int closedCount = 0;
    double totalProfit = 0;

    trade.SetExpertMagicNumber((int)Magic);
    trade.SetDeviationInPoints(50);

    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && ShouldManagePosition(ticket))
        {
            if(PositionSelectByTicket(ticket))
            {
                string symbol = PositionGetString(POSITION_SYMBOL);
                double volume = PositionGetDouble(POSITION_VOLUME);
                ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                double profit = PositionGetDouble(POSITION_PROFIT);

                Print("âš¡ Alternative closure for position: ", ticket);

                if(trade.PositionClose(symbol, 50))
                {
                    closedCount++;
                    totalProfit += profit;
                    Print("âœ… Alternative closure successful: ", ticket, " Type: ", EnumToString(type));
                }
            }
        }
    }

    if(closedCount > 0)
        PrintFormat("âœ… Alternative closure completed. Closed: %d positions", closedCount);
}

bool SafePositionCloseImmediate(ulong ticket)
{
    if(ticket == 0 || !PositionSelectByTicket(ticket))
    {
        Print("âš ï¸ Invalid ticket for closure: ", ticket);
        return false;
    }

    double volume = PositionGetDouble(POSITION_VOLUME);
    ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
    double profitBeforeClose = PositionGetDouble(POSITION_PROFIT);
    string symbol = PositionGetString(POSITION_SYMBOL);

    MqlTradeRequest request;
    MqlTradeResult  result;
    ZeroMemory(request);
    ZeroMemory(result);

    request.action   = TRADE_ACTION_DEAL;
    request.position = ticket;
    request.symbol   = symbol;
    request.volume   = volume;
    request.deviation= 50;
    request.magic    = Magic;
    request.comment  = "EA_Force_Close";

    if(type == POSITION_TYPE_BUY)
    {
        request.price = SymbolInfoDouble(symbol, SYMBOL_BID);
        request.type  = ORDER_TYPE_SELL;
    }
    else
    {
        request.price = SymbolInfoDouble(symbol, SYMBOL_ASK);
        request.type  = ORDER_TYPE_BUY;
    }

    bool success = OrderSend(request, result);

    if(success && result.retcode == TRADE_RETCODE_DONE)
    {
        cumulativeRealizedProfit += profitBeforeClose;
        positionsDirty = true;

        PrintFormat("âœ… Position closed successfully: %I64d, Profit: %.2f ğŸ’–", ticket, profitBeforeClose);
        return true;
    }
    else
    {
        PrintFormat("âš ï¸ Failed to close position %I64d. Error: %d", ticket, result.retcode);
        return false;
    }
}

//+------------------------------------------------------------------+
//| ğŸ¨ CANDLE COLORING & DYNAMIC VISUALS                           |
//+------------------------------------------------------------------+
void ApplyCandleColorSettings()
{
    if(EnableCandleColoring != TRUE) return;

    ChartSetInteger(0, CHART_COLOR_BACKGROUND, Chart_Background);
    ChartSetInteger(0, CHART_COLOR_FOREGROUND, Chart_Foreground);
    ChartSetInteger(0, CHART_COLOR_GRID, clrNONE);

    ChartSetInteger(0, CHART_COLOR_CHART_UP, Candle_Bull_Color);
    ChartSetInteger(0, CHART_COLOR_CHART_DOWN, Candle_Bear_Color);
    ChartSetInteger(0, CHART_COLOR_CANDLE_BULL, Candle_Bull_Color);
    ChartSetInteger(0, CHART_COLOR_CANDLE_BEAR, Candle_Bear_Color);

    ChartSetInteger(0, CHART_COLOR_BID, BidLineColor);
    ChartSetInteger(0, CHART_COLOR_ASK, AskLineColor);

    currentBullColor = Candle_Bull_Color;
    currentBearColor = Candle_Bear_Color;
    colorsInitialized = true;

    ChartRedraw();
    PrintFormat("âœ… Professional Candle Colors Applied | Bull=%s, Bear=%s", 
                ColorToString(Candle_Bull_Color), ColorToString(Candle_Bear_Color));
}

void UpdateDynamicCandleColors()
{
    if(EnableCandleColoring != TRUE || !DynamicCandleColors) return;

    static datetime lastUpdate = 0;
    if(TimeCurrent() - lastUpdate < ColorUpdateFrequency) return;
    lastUpdate = TimeCurrent();

    double maValue = GetGridMAValue();
    if(maValue <= 0) return;

    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    bool bullishTrend = (currentPrice > maValue);

    color newBullColor = Candle_Bull_Color;
    color newBearColor = Candle_Bear_Color;

    if(bullishTrend && seriesActive && currentSeriesDirection == POSITION_TYPE_BUY)
    {
        newBullColor = ColorToLighter(Candle_Bull_Color, 15);
        newBearColor = ColorToDarker(Candle_Bear_Color, 10);
    }
    else if(!bullishTrend && seriesActive && currentSeriesDirection == POSITION_TYPE_SELL)
    {
        newBearColor = ColorToLighter(Candle_Bear_Color, 15);
        newBullColor = ColorToDarker(Candle_Bull_Color, 10);
    }

    if(newBullColor != currentBullColor || newBearColor != currentBearColor)
    {
        ChartSetInteger(0, CHART_COLOR_CANDLE_BULL, newBullColor);
        ChartSetInteger(0, CHART_COLOR_CANDLE_BEAR, newBearColor);
        ChartSetInteger(0, CHART_COLOR_CHART_UP, newBullColor);
        ChartSetInteger(0, CHART_COLOR_CHART_DOWN, newBearColor);

        currentBullColor = newBullColor;
        currentBearColor = newBearColor;

        ChartRedraw();
        PrintFormat("ğŸ¨ Dynamic Candle Colors Updated | Bull=%s, Bear=%s", 
                    ColorToString(newBullColor), ColorToString(newBearColor));
    }
}

color ColorToLighter(color clr, int percent)
{
    int r = (clr >> 16) & 0xFF;
    int g = (clr >> 8) & 0xFF;
    int b = clr & 0xFF;

    r = MathMin(r + (255 - r) * percent / 100, 255);
    g = MathMin(g + (255 - g) * percent / 100, 255);
    b = MathMin(b + (255 - b) * percent / 100, 255);

    return (color)((r << 16) | (g << 8) | b);
}

color ColorToDarker(color clr, int percent)
{
    int r = (clr >> 16) & 0xFF;
    int g = (clr >> 8) & 0xFF;
    int b = clr & 0xFF;

    r = MathMax(r - r * percent / 100, 0);
    g = MathMax(g - g * percent / 100, 0);
    b = MathMax(b - b * percent / 100, 0);

    return (color)((r << 16) | (g << 8) | b);
}

void CheckLastActionAutoHide()
{
    if(lastActionVisible && (TimeCurrent() - lastActionTime) > 10)
    {
        lastActionVisible = false;
        ObjectDelete(0, "LastActionPanel");
        ObjectDelete(0, "LastActionText");
        ObjectDelete(0, "LastActionShadow");

        Print("ğŸ•’ Last Action panel auto-hidden");
    }
}

//+------------------------------------------------------------------+
//| âš¡ CORE TRADING FUNCTIONS                                       |
//+------------------------------------------------------------------+
bool ShouldManagePosition(ulong ticket)
{
    if(ticket == 0 || !PositionSelectByTicket(ticket)) return false;

    string symbol = PositionGetString(POSITION_SYMBOL);
    long positionMagic = PositionGetInteger(POSITION_MAGIC);

    if(symbol != _Symbol) return false;
    if(ManualHandOrder && positionMagic == 0) return true;
    if(positionMagic == (long)Magic) return true;

    return false;
}

void DebugLogTradingMode()
{
    static bool lastManualMode = OnlyManualTrading;

    if(lastManualMode != OnlyManualTrading)
    {
        Print("=== TRADING MODE SWITCHED ===");
        Print("New Mode: ", OnlyManualTrading ? "MANUAL TRADING MODE" : "AUTOMATIC TRADING MODE");
        Print("Manual Mode Behavior: ", OnlyManualTrading ? 
              "EA will MANAGE existing positions but NOT open new ones" : 
              "EA will OPEN and MANAGE positions automatically");
        Print("Positions being managed: ", GetCachedTotalPositions());
        Print("=============================");

        lastManualMode = OnlyManualTrading;
    }
}

void TestManualTradingMode()
{
    if(OnlyManualTrading)
    {
        Print("=== MANUAL MODE TEST ===");
        Print("âœ“ Opening Logic: DISABLED");
        Print("âœ“ Management Logic: ACTIVE");
        Print("âœ“ Managing ", GetCachedBuyPositions(), " BUY positions");
        Print("âœ“ Managing ", GetCachedSellPositions(), " SELL positions");
        Print("âœ“ Total positions: ", GetCachedTotalPositions());
        Print("========================");
    }
}

void ApplyChartVisualSettings()
{
    if(!EnableChartVisuals) return;

    ChartSetInteger(0, CHART_SHOW_TRADE_HISTORY, false);
    ChartSetInteger(0, CHART_SHOW_TRADE_LEVELS, true);
    ChartSetInteger(0, CHART_SHOW_OBJECT_DESCR, false);

    if(EnableCandleColoring == TRUE && !colorsInitialized)
        ApplyCandleColorSettings();

    ChartSetInteger(0, CHART_SHOW_TRADE_LEVELS, ShowTradeLevels);
    ChartSetInteger(0, CHART_SHOW_BID_LINE, ShowBidAskLines);
    ChartSetInteger(0, CHART_SHOW_ASK_LINE, ShowBidAskLines);
    ChartSetInteger(0, CHART_COLOR_BID, BidLineColor);
    ChartSetInteger(0, CHART_COLOR_ASK, AskLineColor);

    if(KeepChartStable)
    {
        ChartSetInteger(0, CHART_SHIFT, true);

        if(!chartInitialized)
        {
            ChartSetInteger(0, CHART_AUTOSCROLL, false);
            chartInitialized = true;
        }
        else if(EnableAutoScroll)
        {
            ChartSetInteger(0, CHART_AUTOSCROLL, true);
            ChartSetInteger(0, CHART_SHIFT, true);
        }
        else
        {
            ChartSetInteger(0, CHART_AUTOSCROLL, false);
            ChartSetInteger(0, CHART_SHIFT, true);
        }
    }
    else
    {
        ChartSetInteger(0, CHART_AUTOSCROLL, EnableAutoScroll);
        ChartSetInteger(0, CHART_SHIFT, EnableAutoScroll ? false : true);
    }

    ChartRedraw();
}

double GetBaseLotSize()
{
    if(Autolot_ != TRUE) return NormalizeToLotStep(Lot_Init_);

    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    double lots = 0.01 * equity / Autolotsize_;
    lots = NormalizeToLotStep(lots);

    lots = MathMax(MathMin(lots, MathMin(MaxLot_, maxLot)), minLot);
    return lots;
}

double NormalizeToLotStep(double lots)
{
    if(lotStep <= 0) lotStep = 0.01;
    double steps = lots / lotStep;
    steps = MathRound(steps);
    return steps * lotStep;
}

int GetCachedBuyPositions()
{
    if(cachedBuyPositions == -1 || positionsDirty) 
        cachedBuyPositions = CountOpenPositionsOfType(POSITION_TYPE_BUY);
    return cachedBuyPositions;
}

int GetCachedSellPositions()
{
    if(cachedSellPositions == -1 || positionsDirty)
        cachedSellPositions = CountOpenPositionsOfType(POSITION_TYPE_SELL);
    return cachedSellPositions;
}

int GetCachedTotalPositions()
{
    return GetCachedBuyPositions() + GetCachedSellPositions();
}

//+------------------------------------------------------------------+
//| ğŸ¯ ENHANCED IS ANY POSITION IN PROFIT                          |
//| Returns true if ANY position of given type is in profit         |
//+------------------------------------------------------------------+
bool IsAnyPositionInProfit(ENUM_POSITION_TYPE type)
{
    int total = PositionsTotal();
    for(int i = 0; i < total; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;
        if(PositionGetInteger(POSITION_TYPE) != (int)type) continue;

        double profit = PositionGetDouble(POSITION_PROFIT);
        if(profit > 0.01) 
        {
            PrintFormat("Found %s position in profit: Ticket=%I64d, Profit=$%.2f",
                       EnumToString(type), ticket, profit);
            return true;
        }
    }
    return false;
}

double CalculateTotalFloatingProfit()
{
    double totalProfit = 0;
    int total = PositionsTotal();
    for(int i = 0; i < total; i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket > 0 && ShouldManagePosition(ticket))
            totalProfit += PositionGetDouble(POSITION_PROFIT);
    }
    return totalProfit;
}

void ResetStatesVirtual()
{
    firstBuyLotTicket = 0;
    firstSellLotTicket = 0;
    cumulativeRealizedProfit = 0.0;
    stopLossHit = false;

    breakEvenPrice = 0.0;
    breakEvenActive = false;
    breakEvenTriggerPrice = 0.0;
    breakEvenBasePrice = 0.0;
    breakEvenPositionsClosed = 0;

    positionsDirty = true;
    initialBuyBaseLot = 0.0;
    initialSellBaseLot = 0.0;
    currentBarTime = 0;
    lastTradeBarTime = 0;

    string objNames[] = {"FirstBuyTPLine", "FirstSellTPLine", "FirstBuyTPText", 
                         "FirstSellTPText", "BreakEvenLine", "BreakEvenText"};

    for(int i = 0; i < ArraySize(objNames); i++)
        if(ObjectFind(0, objNames[i]) >= 0) ObjectDelete(0, objNames[i]);

    Print("âœ… All trading states reset after position closure");
}

//+------------------------------------------------------------------+
//| ğŸš¨ CHECK IF TRADING IS ALLOWED                                   |
//+------------------------------------------------------------------+
bool IsTradingAllowed()
{
    // ğŸš¨ Check global halt conditions first
    if(tradingHalted || profitTargetHit || lossLimitHit)
    {
        if(EnableDebugLog) 
            Print("âš ï¸ TRADING BLOCKED: Profit/Loss target active or trading halted");
        return false;
    }

    // Manual mode allows management only (not auto-trading)
    if(OnlyManualTrading) return true;

    // MinuteStop: stop trading after X minutes since start
    if(MinuteStop > 0 && (TimeCurrent() - startTime) >= MinuteStop * 60)
    {
        if(EnableDebugLog) Print("âš ï¸ TRADING BLOCKED: MinuteStop reached");
        return false;
    }

    // Stop loss hit: prevent trading
    if(stopLossHit)
    {
        if(EnableDebugLog) Print("âš ï¸ TRADING BLOCKED: Stop loss hit");
        return false;
    }

    // Time window check
    MqlDateTime now;
    TimeToStruct(TimeCurrent(), now);
    int nowSec = now.hour * 3600 + now.min * 60 + now.sec;
    int startSec = ParseTimeToSeconds(Start_Hour);
    int endSec   = ParseTimeToSeconds(End_Hour);

    if(startSec < endSec)
    {
        if(nowSec < startSec || nowSec >= endSec)
        {
            if(EnableDebugLog) Print("âš ï¸ TRADING BLOCKED: Outside trading hours");
            return false;
        }
    }
    else // Overnight session
    {
        if(nowSec < startSec && nowSec >= endSec)
        {
            if(EnableDebugLog) Print("âš ï¸ TRADING BLOCKED: Outside trading hours");
            return false;
        }
    }

    return true; // Trading allowed
}

//+------------------------------------------------------------------+
//| âœ… CHECK TRADING STATUS WITH REASON                               |
//+------------------------------------------------------------------+
string IsTradingAllowedWithReason()
{
    if(tradingHalted)
    {
        if(profitTargetHit) return "BLOCKED: Daily Profit Target Reached";
        if(lossLimitHit)   return "BLOCKED: Daily Loss Limit Reached";
        return "BLOCKED: Trading halted";
    }

    if(OnlyManualTrading) return "OK - Manual Trading Mode (Management Only)";
    if(MinuteStop > 0 && (TimeCurrent() - startTime) >= MinuteStop * 60) return "BLOCKED: MinuteStop reached";
    if(stopLossHit) return "BLOCKED: Stop loss hit";

    int startSec = ParseTimeToSeconds(Start_Hour);
    int endSec   = ParseTimeToSeconds(End_Hour);

    MqlDateTime now;
    TimeToStruct(TimeCurrent(), now);
    int nowSec = now.hour * 3600 + now.min * 60 + now.sec;

    if(startSec < endSec)
    {
        if(nowSec < startSec || nowSec >= endSec) return "BLOCKED: Outside trading hours";
    }
    else
    {
        if(nowSec < startSec && nowSec >= endSec) return "BLOCKED: Outside trading hours";
    }

    return "OK";
}

//+------------------------------------------------------------------+
//| â± PARSE HH:MM STRING TO SECONDS                                   |
//+------------------------------------------------------------------+
int ParseTimeToSeconds(string hhmm)
{
    if(StringLen(hhmm) < 4) return 0;
    int hour = StringToIntegerCustom(StringSubstrCustom(hhmm, 0, 2));
    int min  = StringToIntegerCustom(StringSubstrCustom(hhmm, 3, 2));
    return hour * 3600 + min * 60;
}

//+------------------------------------------------------------------+
//| ğŸ¯ ENHANCED RECALCULATE MARTINGALE STATE                        |
//| Based ONLY on currently open positions                          |
//+------------------------------------------------------------------+
void RecalculateMartingaleState()
{
    // Reset sequences based on ACTIVE open positions
    buyMartingaleSequence = CountOpenPositionsOfType(POSITION_TYPE_BUY);
    sellMartingaleSequence = CountOpenPositionsOfType(POSITION_TYPE_SELL);
    
    // Reset lot tracking
    lastBuyLot = 0.0;
    lastSellLot = 0.0;
    lastBuyPrice = 0.0;
    lastSellPrice = 0.0;
    
    // Find most recent prices and lots
    datetime latestBuyTime = 0;
    datetime latestSellTime = 0;
    ulong tempFirstBuyTicket = 0;
    ulong tempFirstSellTicket = 0;
    datetime earliestBuyTime = LONG_MAX;
    datetime earliestSellTime = LONG_MAX;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0 || !ShouldManagePosition(ticket)) continue;
        
        ENUM_POSITION_TYPE ptype = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
        datetime openTime = (datetime)PositionGetInteger(POSITION_TIME);
        double volume = PositionGetDouble(POSITION_VOLUME);
        double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
        
        if(ptype == POSITION_TYPE_BUY)
        {
            if(openTime > latestBuyTime)
            {
                latestBuyTime = openTime;
                lastBuyLot = volume;
                lastBuyPrice = openPrice;
            }
            
            if(openTime < earliestBuyTime)
            {
                earliestBuyTime = openTime;
                tempFirstBuyTicket = ticket;
                initialBuyBaseLot = volume;
            }
        }
        else if(ptype == POSITION_TYPE_SELL)
        {
            if(openTime > latestSellTime)
            {
                latestSellTime = openTime;
                lastSellLot = volume;
                lastSellPrice = openPrice;
            }
            
            if(openTime < earliestSellTime)
            {
                earliestSellTime = openTime;
                tempFirstSellTicket = ticket;
                initialSellBaseLot = volume;
            }
        }
    }
    
    // Update tickets
    firstBuyLotTicket = tempFirstBuyTicket;
    firstSellLotTicket = tempFirstSellTicket;
    
    // Update series direction
    if(buyMartingaleSequence > 0 && sellMartingaleSequence == 0)
    {
        currentSeriesDirection = POSITION_TYPE_BUY;
        seriesActive = true;
    }
    else if(sellMartingaleSequence > 0 && buyMartingaleSequence == 0)
    {
        currentSeriesDirection = POSITION_TYPE_SELL;
        seriesActive = true;
    }
    else if(buyMartingaleSequence > 0 && sellMartingaleSequence > 0)
    {
        // Mixed positions - determine dominant direction
        currentSeriesDirection = (buyMartingaleSequence >= sellMartingaleSequence) ? 
                                POSITION_TYPE_BUY : POSITION_TYPE_SELL;
        seriesActive = true;
    }
    else
    {
        seriesActive = false;
        currentSeriesDirection = WRONG_VALUE;
    }
    
    PrintFormat("Recalc Martingale: BuySeq=%d (Open=%d), SellSeq=%d (Open=%d), Series=%s",
                buyMartingaleSequence, CountOpenPositionsOfType(POSITION_TYPE_BUY),
                sellMartingaleSequence, CountOpenPositionsOfType(POSITION_TYPE_SELL),
                seriesActive ? EnumToString(currentSeriesDirection) : "NONE");
}

//+------------------------------------------------------------------+
//| ğŸŸ¢ TRADING STRATEGIES - GRID & MA BASED LOGIC                   |
//+------------------------------------------------------------------+
void CheckNewCandle()
{
    datetime currentTime = iTime(_Symbol, PERIOD_CURRENT, 0);

    if(currentTime != currentCandleTime)
    {
        currentCandleTime = currentTime;
        newCandleFlag     = true;
    }
    else
    {
        newCandleFlag = false;
    }
}

double GetGridMAValue()
{
    if(hGridMA == INVALID_HANDLE) 
    {
        hGridMA = iMA(_Symbol, Grid_MA_Timeframe, Grid_MA_Period, 0, Grid_MA_Method, Grid_MA_Price);
        if(hGridMA == INVALID_HANDLE) return 0;
    }

    double maValue[1];
    if(CopyBuffer(hGridMA, 0, 0, 1, maValue) <= 0) return 0;

    return maValue[0];
}

bool ShouldOpenTradeByMA(ENUM_ORDER_TYPE type)
{
    if(OnlyManualTrading) return false;

    if(seriesActive)
    {
        if(currentSeriesDirection == POSITION_TYPE_BUY  && type == ORDER_TYPE_BUY)  return true;
        if(currentSeriesDirection == POSITION_TYPE_SELL && type == ORDER_TYPE_SELL) return true;
        return false;
    }

    double currentPrice = (type == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                                                   : SymbolInfoDouble(_Symbol, SYMBOL_BID);

    double maValue = GetGridMAValue();
    if(maValue <= 0) return false;

    if(type == ORDER_TYPE_BUY)  return currentPrice > maValue;
    if(type == ORDER_TYPE_SELL) return currentPrice < maValue;

    return false;
}

bool IsNewBarConfirmed()
{
    datetime newBarTime = iTime(_Symbol, OneBarTimeframe, 0);
    double currentOpen  = iOpen(_Symbol, OneBarTimeframe, 0);
    
    if(newBarTime != currentBarTime)
    {
        barChangeCounter++;
        currentBarTime     = newBarTime;
        lastBarOpenPrice   = currentOpen;

        if(barChangeCounter >= MinBarChangeChecks)
        {
            newBarConfirmed = true;
            barChangeCounter = 0;
            Print("ğŸ’ New bar confirmed: ", TimeToString(newBarTime), " | Open: ", currentOpen);
            return true;
        }
    }
    else
    {
        barChangeCounter = 0;
        newBarConfirmed = false;
    }

    return false;
}

bool CanTradeThisBarEnhanced(ENUM_POSITION_TYPE tradeType)
{
    if(!GridSingleTradePerBar) return true;

    if(IsNewBarConfirmed())
    {
        lastTradeBarTime = currentBarTime;
        Print("ğŸ± New trading bar started - Reset trade permissions â¤ï¸");
        return true;
    }

    if(currentBarTime == lastTradeBarTime)
    {
        if(AllowMultipleSeriesPerBar)
        {
            if(!seriesActive || currentSeriesDirection == tradeType)
                return true;
        }
        return false;
    }

    return true;
}

bool CanStartNewSeries(ENUM_POSITION_TYPE type)
{
    if(GetCachedTotalPositions() == 0) return true;
    if(!seriesActive) return true;
    if(seriesActive && currentSeriesDirection != type) return false;

    return true;
}

//+------------------------------------------------------------------+
//| ğŸ“ˆ ENHANCED CHECK STOCHASTIC SIGNALS WITH FIXED MARTINGALE     |
//+------------------------------------------------------------------+
void CheckStochasticSignals()
{
    if(OnlyManualTrading || Use_Stoh != TRUE) 
        return;

    // ğŸš¨ CRITICAL FIX: STOP EXECUTION IF TRADING IS HALTED
    if(tradingHalted)
    {
        if(EnableDebugLog)
            Print("ğŸš¨ Stochastic Signals: Trading halted, skipping execution");
        return;
    }

    // ğŸ”§ Initialize indicator if needed
    if(hStochastic == INVALID_HANDLE)
    {
        hStochastic = iStochastic(_Symbol, TF_Stoh, KPeriod, DPeriod, Slowing, 
                                  MODE_SMA, STO_LOWHIGH);
        if(hStochastic == INVALID_HANDLE)
            return;
    }

    double stochMain[], stochSignal[];
    ArraySetAsSeries(stochMain,  true);
    ArraySetAsSeries(stochSignal, true);

    if(CopyBuffer(hStochastic, 0, 0, 3, stochMain)   != 3) return;
    if(CopyBuffer(hStochastic, 1, 0, 3, stochSignal) != 3) return;

    double cur = stochMain[0];
    double prv = stochMain[1];

    bool buySignal  = (prv < Down_Level) && (cur > Down_Level);
    bool sellSignal = (prv > Up_Level)   && (cur < Up_Level);

    // ğŸ¯ MARTINGALE CHECKS
    bool canPlaceBuy  = true;
    bool canPlaceSell = true;
    
    if(buySignal)
    {
        int openBuyPositions = CountOpenPositionsOfType(POSITION_TYPE_BUY);
        if(openBuyPositions > 0)
        {
            canPlaceBuy = CanPlaceMartingaleOrder(POSITION_TYPE_BUY);
            PrintFormat("Stoch Buy Martingale: Open=%d, Allow=%s", 
                        openBuyPositions,
                        canPlaceBuy ? "YES" : "NO");
        }
    }
    
    if(sellSignal)
    {
        int openSellPositions = CountOpenPositionsOfType(POSITION_TYPE_SELL);
        if(openSellPositions > 0)
        {
            canPlaceSell = CanPlaceMartingaleOrder(POSITION_TYPE_SELL);
            PrintFormat("Stoch Sell Martingale: Open=%d, Allow=%s", 
                        openSellPositions,
                        canPlaceSell ? "YES" : "NO");
        }
    }

    // ğŸš€ EXECUTE BUY
    if(buySignal && canPlaceBuy && Flag_Trade_Buy_ &&
       GetCachedBuyPositions() < MaxOrdersBuy &&
       CanStartNewSeries(POSITION_TYPE_BUY))
    {
        OpenTrade(ORDER_TYPE_BUY);
    }

    // ğŸš€ EXECUTE SELL
    if(sellSignal && canPlaceSell && Flag_Trade_Sell_ &&
       GetCachedSellPositions() < MaxOrdersSell &&
       CanStartNewSeries(POSITION_TYPE_SELL))
    {
        OpenTrade(ORDER_TYPE_SELL);
    }
}

void UpdateFirstLotTPLines()
{
   if(EnableFirstLotTP != TRUE || !ShowTPLine)
   {
      ObjectsDeleteAll(0,"FirstBuyTPLine");
      ObjectsDeleteAll(0,"FirstSellTPLine");
      ObjectsDeleteAll(0,"FirstBuyTPText");
      ObjectsDeleteAll(0,"FirstSellTPText");
      return;
   }
   
   if((buyMartingaleSequence >= 2 && firstBuyLotTicket != 0) || (sellMartingaleSequence >= 2 && firstSellLotTicket != 0))
   {
      ObjectDelete(0,"FirstBuyTPLine");
      ObjectDelete(0,"FirstBuyTPText");
      ObjectDelete(0,"FirstSellTPLine");
      ObjectDelete(0,"FirstSellTPText");
      return;
   }
   
   if(firstBuyLotTicket!=0&&PositionSelectByTicket(firstBuyLotTicket)&&buyMartingaleSequence==1)
   {
      double openPrice=PositionGetDouble(POSITION_PRICE_OPEN);
      double tpPrice=openPrice+(FirstLotTPPoints*g_point);
      
      if(ObjectFind(0,"FirstBuyTPLine")<0)
      {
         ObjectCreate(0,"FirstBuyTPLine",OBJ_HLINE,0,0,tpPrice);
         ObjectSetInteger(0,"FirstBuyTPLine",OBJPROP_COLOR,TPLineColor);
         ObjectSetInteger(0,"FirstBuyTPLine",OBJPROP_WIDTH,2); // Increased width
         ObjectSetInteger(0,"FirstBuyTPLine",OBJPROP_STYLE,STYLE_SOLID);
         ObjectSetInteger(0,"FirstBuyTPLine",OBJPROP_BACK,true);
      }
      else ObjectMove(0,"FirstBuyTPLine",0,0,tpPrice);
      
      if(ObjectFind(0,"FirstBuyTPText")<0)
      {
         ObjectCreate(0,"FirstBuyTPText",OBJ_TEXT,0,TimeCurrent(),tpPrice);
         ObjectSetString(0,"FirstBuyTPText",OBJPROP_TEXT,"  ğŸ¯ BUY TP ğŸ¯"); // Added emojis and made text more prominent
         ObjectSetInteger(0,"FirstBuyTPText",OBJPROP_COLOR,clrLime);
         ObjectSetInteger(0,"FirstBuyTPText",OBJPROP_FONTSIZE,10); // Increased font size
         ObjectSetString(0,"FirstBuyTPText",OBJPROP_FONT,"Arial Black"); // More bold font
         ObjectSetInteger(0,"FirstBuyTPText",OBJPROP_ANCHOR,ANCHOR_LEFT_UPPER);
         ObjectSetInteger(0,"FirstBuyTPText",OBJPROP_BACK,false);
         ObjectSetInteger(0,"FirstBuyTPText",OBJPROP_ZORDER,1000); // Ensure text is on top
      }
      else ObjectMove(0,"FirstBuyTPText",0,TimeCurrent(),tpPrice);
   }
   else
   {
      ObjectDelete(0,"FirstBuyTPLine");
      ObjectDelete(0,"FirstBuyTPText");
   }
   
   if(firstSellLotTicket!=0&&PositionSelectByTicket(firstSellLotTicket)&&sellMartingaleSequence==1)
   {
      double openPrice=PositionGetDouble(POSITION_PRICE_OPEN);
      double tpPrice=openPrice-(FirstLotTPPoints*g_point);
      
      if(ObjectFind(0,"FirstSellTPLine")<0)
      {
         ObjectCreate(0,"FirstSellTPLine",OBJ_HLINE,0,0,tpPrice);
         ObjectSetInteger(0,"FirstSellTPLine",OBJPROP_COLOR,TPLineColor);
         ObjectSetInteger(0,"FirstSellTPLine",OBJPROP_WIDTH,2); // Increased width
         ObjectSetInteger(0,"FirstSellTPLine",OBJPROP_STYLE,STYLE_SOLID);
         ObjectSetInteger(0,"FirstSellTPLine",OBJPROP_BACK,true);
      }
      else ObjectMove(0,"FirstSellTPLine",0,0,tpPrice);
      
      if(ObjectFind(0,"FirstSellTPText")<0)
      {
         ObjectCreate(0,"FirstSellTPText",OBJ_TEXT,0,TimeCurrent(),tpPrice);
         ObjectSetString(0,"FirstSellTPText",OBJPROP_TEXT,"  ğŸ¯ SELL TP ğŸ¯"); // Added emojis and made text more prominent
         ObjectSetInteger(0,"FirstSellTPText",OBJPROP_COLOR,clrLime);
         ObjectSetInteger(0,"FirstSellTPText",OBJPROP_FONTSIZE,10); // Increased font size
         ObjectSetString(0,"FirstSellTPText",OBJPROP_FONT,"Arial Black"); // More bold font
         ObjectSetInteger(0,"FirstSellTPText",OBJPROP_ANCHOR,ANCHOR_LEFT_UPPER);
         ObjectSetInteger(0,"FirstSellTPText",OBJPROP_BACK,false);
         ObjectSetInteger(0,"FirstSellTPText",OBJPROP_ZORDER,1000); // Ensure text is on top
      }
      else ObjectMove(0,"FirstSellTPText",0,TimeCurrent(),tpPrice);
   }
   else
   {
      ObjectDelete(0,"FirstSellTPLine");
      ObjectDelete(0,"FirstSellTPText");
   }
}

void CheckVirtualStopLoss()
{
    if(EnableVirtualStopLoss != TRUE || StopLossPoints <= 0) return;

    if(seriesActive)
    {
        double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        bool shouldClose = false;

        if(currentSeriesDirection == POSITION_TYPE_BUY && currentBid <= virtualStopLossLevel)
            shouldClose = true;
        else if(currentSeriesDirection == POSITION_TYPE_SELL && currentAsk >= virtualStopLossLevel)
            shouldClose = true;

        if(shouldClose && !stopLossHit)
        {
            Print("ğŸŠ Virtual Stop Loss triggered at level: ", virtualStopLossLevel);
            ForceCloseAllPositions();
            stopLossHit = true;
        }
    }
}

void UpdateBreakEvenLine()
{
    if(!EnableBreakEven)
    {
        ObjectDelete(0, "BreakEvenLine");
        ObjectDelete(0, "BreakEvenText");
        return;
    }

    if(!seriesActive)
    {
        breakEvenPrice      = 0.0;
        breakEvenBasePrice  = 0.0;
        breakEvenActive     = false;
        ObjectDelete(0, "BreakEvenLine");
        ObjectDelete(0, "BreakEvenText");
        return;
    }

    if(seriesActive && GetCachedTotalPositions() >= 2)
    {
        double totalVolume   = 0.0;
        double weightedPrice = 0.0;
        int total = PositionsTotal();

        for(int i = 0; i < total; i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(ShouldManagePosition(ticket))
            {
                double volume     = PositionGetDouble(POSITION_VOLUME);
                double openPrice  = PositionGetDouble(POSITION_PRICE_OPEN);

                totalVolume   += volume;
                weightedPrice += volume * openPrice;
            }
        }

        if(totalVolume > 0)
        {
            breakEvenPrice  = weightedPrice / totalVolume;
            breakEvenActive = true;
            Print("ğŸ‰ Break-even recalculated: ", breakEvenPrice, " (Volume-weighted avg) ğŸ‰");
        }
    }

    if(breakEvenActive && breakEvenPrice > 0)
    {
        if(ObjectFind(0, "BreakEvenLine") < 0)
        {
            ObjectCreate(0, "BreakEvenLine", OBJ_HLINE, 0, 0, breakEvenPrice);
            ObjectSetInteger(0, "BreakEvenLine", OBJPROP_COLOR, BreakEvenLineColor); // Original color preserved
            ObjectSetInteger(0, "BreakEvenLine", OBJPROP_WIDTH, 2); // Increased width for better visibility
            ObjectSetInteger(0, "BreakEvenLine", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, "BreakEvenLine", OBJPROP_BACK, true);
        }
        else
        {
            ObjectMove(0, "BreakEvenLine", 0, 0, breakEvenPrice);
        }

        if(ObjectFind(0, "BreakEvenText") < 0)
        {
            ObjectCreate(0, "BreakEvenText", OBJ_TEXT, 0, TimeCurrent(), breakEvenPrice);
            ObjectSetString(0, "BreakEvenText", OBJPROP_TEXT, "ğŸ›¡ï¸ BREAK EVEN ğŸ›¡ï¸"); // Added emojis and made text more prominent
            ObjectSetInteger(0, "BreakEvenText", OBJPROP_COLOR, clrGold); // Original color preserved
            ObjectSetInteger(0, "BreakEvenText", OBJPROP_FONTSIZE, 10); // Increased font size
            ObjectSetString(0, "BreakEvenText", OBJPROP_FONT, "Arial Black"); // More bold font
            ObjectSetInteger(0, "BreakEvenText", OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
            ObjectSetInteger(0, "BreakEvenText", OBJPROP_BACK, false);
            ObjectSetInteger(0, "BreakEvenText", OBJPROP_ZORDER, 1000); // Ensure text is on top
        }
        else
        {
            ObjectMove(0, "BreakEvenText", 0, TimeCurrent(), breakEvenPrice);
        }
    }
    else
    {
        ObjectDelete(0, "BreakEvenLine");
        ObjectDelete(0, "BreakEvenText");
    }
}

void CheckBreakEven()
{
    if(!EnableBreakEven || !seriesActive) return;

    double currentBid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double currentAsk = SymbolInfoDouble(_Symbol, SYMBOL_ASK);

    UpdateBreakEvenLine();

    bool shouldClose = false;

    if(breakEvenActive && breakEvenPrice > 0)
    {
        if(currentSeriesDirection == POSITION_TYPE_BUY && currentBid >= breakEvenPrice)  shouldClose = true;
        if(currentSeriesDirection == POSITION_TYPE_SELL && currentAsk <= breakEvenPrice) shouldClose = true;

        if(shouldClose)
        {
            Print("ğŸ Break-even level reached: ", breakEvenPrice);
            CloseBreakEvenPositions();

            breakEvenActive     = false;
            breakEvenPrice      = 0.0;
            breakEvenBasePrice  = 0.0;

            ObjectDelete(0, "BreakEvenLine");
            ObjectDelete(0, "BreakEvenText");
        }
    }
}

void CloseBreakEvenPositions()
{
    int totalPositions = GetCachedTotalPositions();
    if(totalPositions == 0) return;

    int positionsToClose = (int)MathMax(1, MathRound(totalPositions * BreakEvenClosePercent / 100.0));
    PrintFormat("ğŸ‰ Closing %d positions (%d%%) due to BreakEven ğŸ‰", positionsToClose, (int)BreakEvenClosePercent);

    int closedCount = 0;
    double totalProfit = 0;

    // Track positions before closure
    int positionsBefore = CountAllEAPositions();
    
    if(CloseOldestFirst)
    {
        for(int i = 0; i < PositionsTotal() && closedCount < positionsToClose; i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(ShouldManagePosition(ticket))
            {
                if(PositionSelectByTicket(ticket))
                {
                    double profit = PositionGetDouble(POSITION_PROFIT);
                    if(EnhancedSafePositionClose(ticket))
                    {
                        closedCount++;
                        totalProfit += profit;
                        breakEvenPositionsClosed++;
                        
                        // Check if this was the last position
                        if(positionsBefore == 1)
                        {
                            Print("ğŸ‰ Break-even closed the LAST position!");
                            ForceMartingaleResetImmediate();
                        }
                        break;
                    }
                }
                Sleep(50);
            }
        }
    }
    else
    {
        for(int i = PositionsTotal()-1; i >=0 && closedCount < positionsToClose; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(ShouldManagePosition(ticket))
            {
                if(PositionSelectByTicket(ticket))
                {
                    double profit = PositionGetDouble(POSITION_PROFIT);
                    if(EnhancedSafePositionClose(ticket))
                    {
                        closedCount++;
                        totalProfit += profit;
                        breakEvenPositionsClosed++;
                        
                        // Check if this was the last position
                        if(positionsBefore == 1)
                        {
                            Print("ğŸ‰ Break-even closed the LAST position!");
                            ForceMartingaleResetImmediate();
                        }
                        break;
                    }
                }
                Sleep(50);
            }
        }
    }
    
    // Final check for empty chart
    if(CountAllEAPositions() == 0)
    {
        Print("ğŸ¯ Break-even system: All positions closed!");
        ForceMartingaleResetImmediate();
    }
    
    if(closedCount > 0) ShowLastAction(totalProfit);
    
    positionsDirty = true;
    PrintFormat("ğŸ Break-even closure completed: %d positions closed ğŸ", closedCount);
}

void UpdateStopLossLine()
{
   if(EnableVirtualStopLoss != TRUE || StopLossPoints <= 0) return;
   
   if(seriesActive)
   {
      double basePrice = 0;
      if(currentSeriesDirection == POSITION_TYPE_BUY && firstBuyLotTicket != 0)
      {
         if(PositionSelectByTicket(firstBuyLotTicket))
         {
            basePrice = PositionGetDouble(POSITION_PRICE_OPEN);
            virtualStopLossLevel = basePrice - PointsToPrice(StopLossPoints);
         }
      }
      else if(currentSeriesDirection == POSITION_TYPE_SELL && firstSellLotTicket != 0)
      {
         if(PositionSelectByTicket(firstSellLotTicket))
         {
            basePrice = PositionGetDouble(POSITION_PRICE_OPEN);
            virtualStopLossLevel = basePrice + PointsToPrice(StopLossPoints);
         }
      }
      
      if(virtualStopLossLevel == 0)
      {
         double currentPrice = (currentSeriesDirection == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         virtualStopLossLevel = (currentSeriesDirection == POSITION_TYPE_BUY) ? currentPrice - PointsToPrice(StopLossPoints) : currentPrice + PointsToPrice(StopLossPoints);
      }
   }
   else virtualStopLossLevel = 0.0;
}

//+------------------------------------------------------------------+
//| ğŸ•¯ FIXED EXECUTE GRID STRATEGY                                 |
//+------------------------------------------------------------------+
void ExecuteGridStrategy()
{
    if(OnlyManualTrading) return;

    // ğŸš¨ CRITICAL FIX: STOP EXECUTION IF TRADING IS HALTED
    if(tradingHalted)
    {
        if(EnableDebugLog)
            Print("ğŸš¨ Grid Strategy: Trading halted, skipping execution");
        return;
    }

    // ğŸ•¯ ONE TRADE PER CANDLE CHECK
    if(EnableOneTradePerCandle == TRUE && !CanTradeCurrentCandleSimple())
    {
        if(EnableDebugLog) 
            Print("ğŸ•¯ Grid Strategy: Candle already traded, skipping");
        return;
    }

    double maValue = GetGridMAValue();
    if(maValue <= 0) return;

    // ğŸ”„ Reset martingale if series active but no positions exist
    if(GetCachedTotalPositions() == 0 && seriesActive)
        UnifiedMartingaleReset();

    bool considerBuy  = ShouldOpenTradeByMA(ORDER_TYPE_BUY);
    bool considerSell = ShouldOpenTradeByMA(ORDER_TYPE_SELL);

    // ğŸ¯ MARTINGALE CHECKS
    bool canPlaceBuy  = true;
    bool canPlaceSell = true;

    if(considerBuy)
    {
        int openBuyPositions = CountOpenPositionsOfType(POSITION_TYPE_BUY);
        if(openBuyPositions > 0)
        {
            canPlaceBuy = CanPlaceMartingaleOrder(POSITION_TYPE_BUY);
            PrintFormat("Grid Buy Martingale: Open=%d, Allow=%s",
                        openBuyPositions,
                        canPlaceBuy ? "YES" : "NO");
        }
    }

    if(considerSell)
    {
        int openSellPositions = CountOpenPositionsOfType(POSITION_TYPE_SELL);
        if(openSellPositions > 0)
        {
            canPlaceSell = CanPlaceMartingaleOrder(POSITION_TYPE_SELL);
            PrintFormat("Grid Sell Martingale: Open=%d, Allow=%s",
                        openSellPositions,
                        canPlaceSell ? "YES" : "NO");
        }
    }

    // ğŸš€ EXECUTE BUY
    if(considerBuy && canPlaceBuy && Flag_Trade_Buy_ &&
       GetCachedBuyPositions() < MaxOrdersBuy &&
       CanStartNewSeries(POSITION_TYPE_BUY))
    {
        OpenTrade(ORDER_TYPE_BUY);
    }

    // ğŸš€ EXECUTE SELL
    if(considerSell && canPlaceSell && Flag_Trade_Sell_ &&
       GetCachedSellPositions() < MaxOrdersSell &&
       CanStartNewSeries(POSITION_TYPE_SELL))
    {
        OpenTrade(ORDER_TYPE_SELL);
    }
}

//+------------------------------------------------------------------+
//| ğŸ’– CORE EVENT HANDLERS                                         |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    if (id == CHARTEVENT_CHART_CHANGE)
    {
        if (EnableInfoPanel == TRUE)
        {
            DeletePanelObjects();
            CreateInfoPanel();
            UpdateInfoPanel();
        }

        if (EnableCandleColoring == TRUE)
        {
            ApplyCandleColorSettings();
        }

        UpdateFirstLotTPLines();
        UpdateBreakEvenLine();
        UpdateLastActionDisplay();

        ApplyChartVisualSettings();

        Print("ğŸ’‹ Chart change detected - Redrawing EA visuals");
    }
}

//+------------------------------------------------------------------+
//| ğŸ’– UPDATED ONTIMER FUNCTION                                    |
//+------------------------------------------------------------------+
void OnTimer()
{
    if (EnableInfoPanel == TRUE)
    {
        UpdateInfoPanel();
    }

    static datetime lastVisualUpdate = 0;
    if (TimeCurrent() - lastVisualUpdate >= 1)
    {
        UpdateFirstLotTPLines();
        UpdateBreakEvenLine();
        UpdateLastActionDisplay();

        if (EnableProfitLossDisplay == TRUE)
            UpdateProfitLossDisplay();

        lastVisualUpdate = TimeCurrent();
    }

    static datetime lastChartCheck = 0;
    if (TimeCurrent() - lastChartCheck >= 3)
    {
        ApplyChartVisualSettings();
        lastChartCheck = TimeCurrent();
    }

    CheckLastActionAutoHide();

    if (EnableProfitLossExit == TRUE && (profitTargetHit || lossLimitHit))
    {
        UpdateFlickerEffect();
    }

    static datetime lastCacheUpdate = 0;
    if (TimeCurrent() - lastCacheUpdate >= 1)
    {
        positionsDirty     = true;
        lastCacheUpdate    = TimeCurrent();
    }
    
    // ğŸš¨ REGULAR RESET VERIFICATION
    static datetime lastResetCheck = 0;
    if(TimeCurrent() - lastResetCheck >= 30) // Check every 30 seconds
    {
        if(CountAllEAPositions() == 0)
        {
            // Run test to verify reset
            TestMartingaleResetScenario();
        }
        lastResetCheck = TimeCurrent();
    }
    
    LogPeriodicStatus();
}

//+------------------------------------------------------------------+
//| ğŸ•¯ FIXED ONTICK FUNCTION WITH GLOBAL TRADING LOCK               |
//+------------------------------------------------------------------+
void OnTick()
{
    // ğŸš¨ GLOBAL TRADING LOCK - PREVENT ANY EXECUTION WHEN HALTED
    if(tradingHalted)
    {
        // Only allow cleanup and display updates, no trading logic
        if(EnableProfitLossExit == TRUE && (profitTargetHit || lossLimitHit))
        {
            UpdateFlickerEffect();
        }
        
        UpdateLastActionDisplay();
        CheckLastActionAutoHide();
        
        // ğŸš¨ EMERGENCY: Double-check if any positions were opened after halt
        static datetime lastEmergencyCheck = 0;
        if(TimeCurrent() - lastEmergencyCheck >= 5)
        {
            int positionsAfterHalt = CountAllEAPositions();
            if(positionsAfterHalt > 0)
            {
                Print("ğŸš¨ EMERGENCY: Positions found after trading halt! Closing immediately...");
                ForceCloseAllPositions();
            }
            lastEmergencyCheck = TimeCurrent();
        }
        
        return; // ğŸš« CRITICAL: STOP ALL FURTHER PROCESSING
    }

    // ğŸš¨ NORMAL ONTICK PROCESSING STARTS HERE
    positionsDirty = true;

    // ğŸš¨ ENHANCED POSITION MONITORING
    EnhancedPositionMonitoring();
    
    // ğŸš¨ DEBUG: Log current state every 5 seconds
    static datetime lastDebugTime = 0;
    if(TimeCurrent() - lastDebugTime >= 5)
    {
        int totalPositions = CountAllEAPositions();
        PrintFormat("ğŸ” DEBUG: Positions=%d, BuySeq=%d, SellSeq=%d, LastBuyLot=%.3f, LastSellLot=%.3f",
                    totalPositions, buyMartingaleSequence, sellMartingaleSequence, 
                    lastBuyLot, lastSellLot);
        
        // Safety check: If positions=0 but sequences>0, force reset
        if(totalPositions == 0 && (buyMartingaleSequence > 0 || sellMartingaleSequence > 0))
        {
            Print("âš ï¸ INCONSISTENT STATE DETECTED: Positions=0 but sequences>0! Forcing reset...");
            ForceMartingaleResetImmediate();
        }
        
        lastDebugTime = TimeCurrent();
    }
    
    if (isProcessing) 
        return;
    
    DebugLogTradingMode();
    
    static datetime lastTestLog = 0;
    if (TimeCurrent() - lastTestLog >= 10)
    {
        TestManualTradingMode();
        lastTestLog = TimeCurrent();
    }
    
    // ğŸ•¯ CHECK FOR NEW CANDLE (One Trade Per Candle System)
    if(EnableOneTradePerCandle == TRUE)
    {
        datetime currentCandle = iTime(_Symbol, TradeTimeframe, 0);
        if(currentCandle != lastCandleTraded)
        {
            candleTradeTaken = false;
            lastCandleTraded = currentCandle;
            
            if(EnableDebugLog) 
                Print("ğŸ•¯ New candle started: ", TimeToString(currentCandle), " | TF: ", EnumToString(TradeTimeframe));
        }
        
        if(ForceTradeEveryCandle == TRUE && !candleTradeTaken)
        {
            ForceTradeOnCurrentCandle();
        }
    }

    static bool firstRun = true;
    if(firstRun || IsStrategyTester())
    {
        InitializeBrokerSettings();
        firstRun = false;
    }

    if (EnableCandleColoring == TRUE && DynamicCandleColors)
    {
        UpdateDynamicCandleColors();
    }

    CheckNewCandle();

    if (positionsDirty)
    {
        RecalculateMartingaleState();
        positionsDirty = false;
    }

    if ((int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) > MaxSpred) 
        return;

    if (EnableProfitLossExit == TRUE && !tradingHalted)
    {
        CheckProfitLoss();
    }

    if (tradingHalted)
    {
        UpdateFlickerEffect();

        if (CloseOnTarget == TRUE && PositionsTotal() > 0)
        {
            Print("âš ï¸ WARNING: Positions still open after target trigger - Force closing...");
            ForceCloseAllPositions();
        }

        return;
    }

    string tradingAllowedReason = IsTradingAllowedWithReason();
    if (tradingAllowedReason != "OK") 
    {
        if (EnableDebugLog) 
            Print("ğŸ’‹ Trading not allowed: ", tradingAllowedReason);
    }

    UpdateStopLossLine();
    CheckVirtualStopLoss();
    
    // ğŸ¯ CRITICAL: Fixed TP calculation
    CheckFirstMartingaleLotTP();
    
    CheckBreakEven();

    // ğŸ¯ FIXED OVERLAP SYSTEM CALL
    CheckSafeOverlapClosure();

    if (EnableProfitLossDisplay == TRUE)
        UpdateProfitLossDisplay();

    if (!OnlyManualTrading)
    {
        if ((TimeCurrent() - lastTradeCheck) >= 1)
        {
            if (Use_Stoh == TRUE) 
                CheckStochasticSignals();
            else 
                ExecuteGridStrategy();

            lastTradeCheck = TimeCurrent();
        }
    }
    else
    {
        if ((TimeCurrent() - lastTradeCheck) >= 5)
        {
            if (EnableDebugLog) 
                Print("ğŸ’‹ Manual Trading Mode: Managing ", GetCachedTotalPositions(), " existing positions");

            lastTradeCheck = TimeCurrent();
        }
    }

    UpdateLastActionDisplay();

    if (TimeCurrent() - lastChartVisualUpdate >= 10)
    {
        ApplyChartVisualSettings();
        lastChartVisualUpdate = TimeCurrent();
    }
    
    // ğŸš¨ FINAL SAFETY CHECK AT END OF ONTICK
    if(CountAllEAPositions() == 0)
    {
        if(buyMartingaleSequence > 0 || sellMartingaleSequence > 0)
        {
            Print("âš ï¸ END OF ONTICK: Chart empty but sequences not reset! Forcing reset...");
            ForceMartingaleResetImmediate();
        }
    }
}

//+------------------------------------------------------------------+
//| ğŸ•¯ UPDATED ONTRADE WITH ENHANCED POSITION MONITORING           |
//+------------------------------------------------------------------+
void OnTrade()
{
    positionsDirty = true;
    RecalculateMartingaleState();
    lastDataUpdate = 0;
    
    // IMMEDIATELY check if chart is empty
    if(CountAllEAPositions() == 0)
    {
        Print("ğŸ”„ OnTrade() detected empty chart - Triggering immediate reset!");
        ForceMartingaleResetImmediate();
    }
    
    if(GetCachedTotalPositions() == 0 && tradingHalted)
    {
        Print("ğŸŒ¸ All positions closed. Trading suspended due to Profit/Loss target reached. Will reset at new day. ğŸŒ¸");
    }
}

//+------------------------------------------------------------------+
//| ğŸ•¯ ENHANCED ONTRADETRANSACTION FUNCTION                        |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                        const MqlTradeRequest& request,
                        const MqlTradeResult& result)
{
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD) 
    {
        ulong dealTicket = trans.deal;
        
        if(dealTicket > 0 && HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
            string symbol = HistoryDealGetString(dealTicket, DEAL_SYMBOL);
            long magic    = HistoryDealGetInteger(dealTicket, DEAL_MAGIC);
            
            if(symbol == _Symbol && (magic == Magic || (ManualHandOrder && magic == 0)))
            {
                Print("ğŸŒŸ Trade closure detected in OnTradeTransaction()");
                
                // IMMEDIATE check for empty chart
                if(CountAllEAPositions() == 0)
                {
                    Print("ğŸš¨ OnTradeTransaction() - Chart empty after closure! Immediate reset.");
                    ForceMartingaleResetImmediate();
                }
                
                EventSetTimer(1);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| ğŸ•¯ UPDATE INIT WITH ENHANCED POSITION MONITORING               |
//+------------------------------------------------------------------+
int OnInit()
{
    ApplyModeSettings();
    ApplyProfitSettingPreset();

    InitializeBrokerSettings();
    AdjustForTesterEnvironment();
    
    Print("âœ… BROKER COMPATIBILITY: Digits=", g_digits, ", Point=", g_point, ", PipValue=", g_pipValue);
    Print("âœ… PROFIT CALCULATION: Using TickValue=", g_tickValue, ", TickSize=", g_tickSize);

    ChartSetInteger(0, CHART_SHOW_TRADE_HISTORY, false);
    ChartSetInteger(0, CHART_SHOW_TRADE_LEVELS, true);
    ChartSetInteger(0, CHART_SHOW_OBJECT_DESCR, false);
    
    Print("âœ… Chart Display Settings Applied:");
    Print("   - All Deal Markers: HIDDEN");
    Print("   - Real Trade OPEN/CLOSE: VISIBLE");
    Print("   - Chart Clutter: REDUCED");

    LogEAInitialization();
    
    Print("ğŸ’ Safe Overlap System: ", EnableSafeOverlap ? "ENABLED ğŸ’š" : "DISABLED ğŸ’”");
    if(EnableSafeOverlap)
    {
        Print("ğŸ“Š Profit Setting Preset: ", EnumToString(ProfitSetting));
        Print("ğŸ”¹ Overlap Points Difference: ", OverlapPointsDifference, " points");
        Print("ğŸ’° Minimum Net Profit: $", DoubleToStringCustom(OverlapMinNetProfit, 2));
        Print("ğŸ’ XAU/USD Point-to-Dollar: Using broker-native tick value calculation");
    }

    Print("ğŸ’– Break-Even System: ", EnableBreakEven ? "ENABLED ğŸ’›" : "DISABLED ğŸ’”");
    if(EnableBreakEven)
    {
        Print("ğŸ”¹ Break-Even Level: ", BreakEvenLevel, " points");
        Print("ğŸ’Œ Break-Even Close %: ", BreakEvenClosePercent, "%");
        Print("ğŸ† Basket Target: $", DoubleToStringCustom(BasketTarget, 2));
    }

    Print("âœ‹ OnlyManualTrading Mode: ", OnlyManualTrading ? "ENABLED - Managing manual trades only ğŸ’Œ" : "DISABLED - Automated trading active ğŸ’š");

    Print("ğŸ’° Profit/Loss Exit: ", EnableProfitLossExit ? "ENABLED ğŸ’" : "DISABLED ğŸ’”");
    if(EnableProfitLossExit)
    {
        Print("ğŸ”¹ Profit Target: $", DoubleToStringCustom(ProfitTarget, 2));
        Print("ğŸ”¹ Loss Limit: $", DoubleToStringCustom(LossLimit, 2));
        Print("ğŸ”’ Close On Target: ", CloseOnTarget ? "Yes ğŸ’š" : "No ğŸ’”");
    }

    if(EnableProfitLossDisplay == TRUE)
    {
        InitializeProfitLossSystem();
        Print("ğŸ“ˆ Profit/Loss Chart Display: ENABLED (NO HISTORY) ğŸ’š");
        Print("ğŸ’Œ Only new trades closed during this session will be displayed");
        Print("ğŸ¨ Profit Color: ", ColorToString(ProfitColor));
        Print("ğŸ”¤ Font: ", FontFace, " Size: ", FontSize);
        Print("ğŸ“ Text Offset: ", TextOffset, " points");
    }

    lastCandleTraded = iTime(_Symbol, TradeTimeframe, 0);
    candleTradeTaken = false;
    consecutiveMissedCandles = 0;
    lastForcedTradeTime = 0;
    
    Print("ğŸ•¯ ENHANCED One Trade Per Candle System: ", EnableOneTradePerCandle ? "ENABLED" : "DISABLED");
    Print("ğŸ•¯ Trading Timeframe: ", EnumToString(TradeTimeframe));
    Print("ğŸ•¯ Force Trade Every Candle: ", ForceTradeEveryCandle ? "ENABLED ğŸ”¥" : "DISABLED");

    ChartSetInteger(0, CHART_SHOW_GRID, false);
    trade.SetExpertMagicNumber((int)Magic);
    trade.SetDeviationInPoints(10);

    minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

    if(Use_Stoh == TRUE)
    {
        hStochastic = iStochastic(_Symbol, TF_Stoh, KPeriod, DPeriod, Slowing, MODE_SMA, STO_LOWHIGH);
        if(hStochastic == INVALID_HANDLE) 
        {
            Print("âŒ ERROR: Failed to initialize Stochastic indicator ğŸ’”");
            return INIT_FAILED;
        }
    }
    else
    {
        hGridMA = iMA(_Symbol, Grid_MA_Timeframe, Grid_MA_Period, 0, Grid_MA_Method, Grid_MA_Price);
        if(hGridMA == INVALID_HANDLE) 
        {
            Print("âŒ ERROR: Failed to initialize Moving Average indicator ğŸ’”");
            return INIT_FAILED;
        }
    }

    initialBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    cachedEquity   = AccountInfoDouble(ACCOUNT_EQUITY);
    cachedBalance  = initialBalance;
    equityBaseLevel = AccountInfoDouble(ACCOUNT_EQUITY);

    dailyStartBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    lastDailyReset = TimeCurrent();

    overlapClosuresCount = 0;
    totalOverlapProfit   = 0.0;

    currentBarTime     = iTime(_Symbol, OneBarTimeframe, 0);
    lastBarOpenPrice   = iOpen(_Symbol, OneBarTimeframe, 0);
    lastTradeBarTime   = 0;

    if(EnableCandleColoring == TRUE)
        ApplyCandleColorSettings();

    ApplyChartVisualSettings();

    for(int i=0; i<20; i++) 
        lastPanelTexts[i] = "";

    RecalculateMartingaleState();

    startTime = TimeCurrent();

    EventSetTimer(1);

    if(EnableInfoPanel == TRUE)
    {
        CreateInfoPanel();
        UpdateInfoPanel();
    }

    Print("âœ¨=== ğŸ’°ğŸŸ¨ NOAHâ€™S ARKâ„¢(XAU) ğŸŸ¨ï¿½ EA v3.16 INITIALIZED SUCCESSFULLY âœ¨===");
    Print("ğŸ¯ FIXED MARTINGALE SYSTEM ENABLED:");
    Print("   âœ… Lot sequence uses largest existing lot as base");
    Print("   âœ… Martingale only when ALL positions in loss");
    Print("   âœ… Proper lot calculation after overlap closures");
    Print("   âœ… Immediate reset when chart is empty");
    Print("ğŸ’ Safe Overlap System: ", EnableSafeOverlap ? "ENABLED ğŸ’š" : "DISABLED ğŸ’”");
    Print("ğŸ“ˆ Profit/Loss Chart Display: ", EnableProfitLossDisplay ? "ENABLED (NO HISTORY) ğŸ’–" : "DISABLED ğŸ’”");
    Print("ğŸ’› Break-Even System: ", EnableBreakEven ? "ENABLED ğŸ’š" : "DISABLED ğŸ’”");
    Print("âœ‹ OnlyManualTrading: ", OnlyManualTrading ? "ENABLED ğŸ’Œ" : "DISABLED ğŸ’š");
    Print("ğŸ”¹ Enhanced One-Bar Trading: ", GridSingleTradePerBar ? "Enabled ğŸ’š" : "Disabled ğŸ’”");
    Print("ğŸ•¯ Professional Candle Coloring: ", EnableCandleColoring ? "Enabled ğŸ’š" : "Disabled ğŸ’”");
    Print("ğŸ’° Profit/Loss Exit System: ", EnableProfitLossExit ? "Enabled ğŸ’" : "Disabled ğŸ’”");
    Print("ğŸ•¯ One Trade Per Candle System: ", EnableOneTradePerCandle ? "ENABLED ğŸ”¥" : "DISABLED");
    Print("=====================================================");

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| ğŸ’– DEINITIALIZATION FUNCTION - ON EA REMOVAL                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    EventKillTimer();

    if(EnableProfitLossDisplay == TRUE) 
        CleanupAllProfitObjects();

    CleanupProfitLossMessages();

    if(hStochastic != INVALID_HANDLE)
    {
        IndicatorRelease(hStochastic);
        hStochastic = INVALID_HANDLE;
    }

    if(hGridMA != INVALID_HANDLE)
    {
        IndicatorRelease(hGridMA);
        hGridMA = INVALID_HANDLE;
    }

    Print("ğŸ’Œ BlackDragon EA deinitialized successfully - History cleared ğŸ’Œ");
}

//+------------------------------------------------------------------+
//| ğŸš¨ EMERGENCY TRADING SHUTDOWN                                  |
//+------------------------------------------------------------------+
void EmergencyTradingShutdown(string reason)
{
    Print("ğŸš¨ğŸš¨ğŸš¨ EMERGENCY TRADING SHUTDOWN ğŸš¨ğŸš¨ğŸš¨");
    Print("Reason: ", reason);
    
    // Set all halt flags
    tradingHalted = true;
    profitTargetHit = true;
    lossLimitHit = true;
    
    // Close all positions immediately
    ForceCloseAllPositions();
    
    // Disable all trading modules
    Flag_Trade_Buy_ = false;
    Flag_Trade_Sell_ = false;
    NewCycle_ = false;
    ManualHandOrder = false;
    
    Print("âœ… Emergency shutdown complete. Trading completely disabled.");
}

//+------------------------------------------------------------------+
//| ğŸ¯ PANEL & DISPLAY FUNCTIONS                                   |
//+------------------------------------------------------------------+
void DeletePanelObjects()
{
    string objects[] = 
    {
        "BD_Panel_Glow1", "BD_Panel_Glow2", "BD_Panel_Back",
        "BD_Panel_HeaderBar", "BD_Panel_HeaderText", "BD_Panel_Header_Under",
        "BD_Block1", "BD_Block2", "BD_Block3", "BD_Algo", "BD_Status",
        "BD_Balance", "BD_Equity", "BD_Float", "BD_Margin", "BD_Free",
        "BD_Level", "BD_PToday", "BD_PWeek", "BD_PMonth", "BD_Strategy",
        "BD_Header2", "BD_BUY", "BD_SELL", "BD_TOTAL"
    };

    for (int i = 0; i < ArraySize(objects); i++)
        if (ObjectFind(0, objects[i]) >= 0)
            ObjectDelete(0, objects[i]);
}

void CreateInfoPanel()
{
    if(EnableInfoPanel != TRUE) return;

    DeletePanelObjects();

    int panelWidth  = 270;
    int panelHeight = 380;
    int x = PanelX;
    int y = PanelY;

    color outerGlow1 = C'20,0,40';
    color outerGlow2 = C'40,0,80';
    color bgColor    = C'18,18,28';
    color headColor  = C'60,0,120';
    color neonAqua   = C'0,255,180';

    CreatePanelRectangle("BD_Panel_Glow1", x-8, y-8, panelWidth+16, panelHeight+16, PanelCorner, outerGlow1, BORDER_FLAT);
    CreatePanelRectangle("BD_Panel_Glow2", x-4, y-4, panelWidth+8, panelHeight+8, PanelCorner, outerGlow2, BORDER_SUNKEN);
    CreatePanelRectangle("BD_Panel_Back",  x,   y, panelWidth, panelHeight, PanelCorner, bgColor, BORDER_FLAT);
    CreatePanelRectangle("BD_Panel_HeaderBar", x, y, panelWidth, 35, PanelCorner, headColor, BORDER_FLAT);

    // Define shining gold color
color goldShine = C'255,215,0';  // RGB for gold

// Create EA name label with shining gold color
CreatePanelLabel("BD_Panel_HeaderText", x-5, y+4, " NOAHâ€™S ARKâ„¢(XAU) ", goldShine, 14, "Arial Black", PanelCorner);
    CreatePanelRectangle("BD_Panel_Header_Under", x+10, y+33, panelWidth-20, 2, PanelCorner, neonAqua, BORDER_FLAT);

    CreatePanelRectangle("BD_Block1", x+10, y+45,  panelWidth-20, 110, PanelCorner, C'22,22,30', BORDER_FLAT);
    CreatePanelRectangle("BD_Block2", x+10, y+165, panelWidth-20, 110, PanelCorner, C'22,22,30', BORDER_FLAT);
    CreatePanelRectangle("BD_Block3", x+10, y+285, panelWidth-20,  80, PanelCorner, C'22,22,30', BORDER_FLAT);

    string objs[] = {
        "BD_Panel_Glow1","BD_Panel_Glow2","BD_Panel_Back",
        "BD_Panel_HeaderBar","BD_Panel_HeaderText","BD_Panel_Header_Under",
        "BD_Block1","BD_Block2","BD_Block3"
    };

    for(int i=0;i<ArraySize(objs);i++)
    {
        if(ObjectFind(0, objs[i]) >= 0)
        {
            ObjectSetInteger(0, objs[i], OBJPROP_SELECTABLE, false);
            ObjectSetInteger(0, objs[i], OBJPROP_HIDDEN, true);
            ObjectSetInteger(0, objs[i], OBJPROP_ZORDER, 0);
        }
    }

    Print("ğŸ’–âœ… Premium Info Panel Created with Love ğŸ’–");
}

void CreatePanelRectangle(string name, int x, int y, int width, int height, int corner, color bgColor, ENUM_BORDER_TYPE border)
{
    if (ObjectFind(0, name) < 0)
    {
        ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_CORNER,       corner);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE,   x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE,   y);
        ObjectSetInteger(0, name, OBJPROP_XSIZE,       width);
        ObjectSetInteger(0, name, OBJPROP_YSIZE,       height);
        ObjectSetInteger(0, name, OBJPROP_BGCOLOR,     bgColor);
        ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, (int)border);
        ObjectSetInteger(0, name, OBJPROP_BORDER_COLOR, clrGray);
        ObjectSetInteger(0, name, OBJPROP_BACK,        false);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE,  false);
        ObjectSetInteger(0, name, OBJPROP_HIDDEN,      true);
        ObjectSetInteger(0, name, OBJPROP_ZORDER,      0);
    }
}

void CreatePanelLabel(string name, int x, int y, string text, color textColor, int fontSize = 10, string font = "Arial", int corner = -1)
{
    if (corner == -1) corner = PanelCorner;

    if (ObjectFind(0, name) < 0)
    {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_CORNER,     corner);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE,  x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE,  y);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    }

    ObjectSetString(0,  name, OBJPROP_TEXT,     text);
    ObjectSetInteger(0, name, OBJPROP_COLOR,    textColor);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
    ObjectSetString(0,  name, OBJPROP_FONT,     font);
}

void CreateOrUpdateLabel(string name, string text, int x, int y, int fontSize, color clr, string font = "Arial")
{
    if (ObjectFind(0, name) < 0)
    {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_CORNER,     PanelCorner);
        ObjectSetInteger(0, name, OBJPROP_XDISTANCE,  x);
        ObjectSetInteger(0, name, OBJPROP_YDISTANCE,  y);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    }

    ObjectSetString(0,  name, OBJPROP_TEXT,     text);
    ObjectSetInteger(0, name, OBJPROP_COLOR,    clr);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
    ObjectSetString(0,  name, OBJPROP_FONT,     font);
}

void UpdateCachedAccountData()
{
    cachedEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
    cachedBalance = AccountInfoDouble(ACCOUNT_BALANCE);

    cachedBuyVolume  = 0; 
    cachedSellVolume = 0; 
    cachedBuyProfit  = 0; 
    cachedSellProfit = 0;

    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(ShouldManagePosition(ticket))
        {
            double vol  = PositionGetDouble(POSITION_VOLUME);
            double prof = PositionGetDouble(POSITION_PROFIT);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

            if(posType == POSITION_TYPE_BUY)
            {
                cachedBuyVolume += vol;
                cachedBuyProfit += prof;
            }
            else if(posType == POSITION_TYPE_SELL)
            {
                cachedSellVolume += vol;
                cachedSellProfit += prof;
            }
        }
    }

    cachedBuyPositions  = CountOpenPositionsOfType(POSITION_TYPE_BUY); 
    cachedSellPositions = CountOpenPositionsOfType(POSITION_TYPE_SELL);
}

void UpdateInfoPanel()
{
    if(EnableInfoPanel != TRUE) return;

    static datetime lastUpdate = 0;
    if(TimeCurrent() - lastUpdate < 0.5) return;
    lastUpdate = TimeCurrent();

    UpdateCachedAccountData();

    int x = PanelX, y = PanelY;
    int labelX = x + 20;
    int line = 18;
    int py = y + 50;

    double balance  = cachedBalance;
    double equity   = cachedEquity;
    double floating = equity - balance;

    double margin      = AccountInfoDouble(ACCOUNT_MARGIN);
    double freeMargin  = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
    double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL);

    int buyCount  = GetCachedBuyPositions();
    int sellCount = GetCachedSellPositions();
    double buyVolume  = cachedBuyVolume;
    double sellVolume = cachedSellVolume;
    double buyProfit  = cachedBuyProfit;
    double sellProfit = cachedSellProfit;

    int totalCount  = buyCount + sellCount;
    double totalVolume = buyVolume + sellVolume;
    double totalProfit = buyProfit + sellProfit;

    MqlDateTime now; 
    TimeCurrent(now);

    datetime todayStart  = TimeCurrent() - (TimeCurrent() % 86400);
    datetime weekStart   = todayStart - (now.day_of_week * 86400);
    datetime monthStart  = todayStart - ((now.day - 1) * 86400);

    double todayProfit   = CalculateClosedProfit(todayStart) + CalculateTodayOpenProfit(todayStart);
    double weeklyProfit  = CalculateClosedProfit(weekStart);
    double monthlyProfit = CalculateClosedProfit(monthStart);

    static bool created = false;
    if(!created) { CreateInfoPanel(); created = true; }

    color txtMain    = C'220,220,230';
    color aquaNeon   = C'0,255,180';
    color limeNeon   = C'0,220,90';
    color redSoft    = C'255,70,70';
    color yellowSoft = C'255,210,0';
    color cyanSoft   = C'0,190,255';

    CreateOrUpdateLabel("BD_Algo",
        "Algo Trading:      " + (IsTradingAllowed() ? "    ENABLE" : "    PAUSED"),
        labelX, py, 10, (IsTradingAllowed() ? limeNeon : redSoft));
    py += line;

    string statusText  = "    ACTIVE";
    color statusColor  = limeNeon;

    if(stopLossHit)        { statusText="STOP LOSS HIT"; statusColor=redSoft; }
    else if(tradingHalted) { statusText="TARGET REACHED"; statusColor=cyanSoft; }

    CreateOrUpdateLabel("BD_Status",
        "Trading Status:   " + statusText,
        labelX, py, 10, statusColor);
    py += line + 6;

    CreateOrUpdateLabel("BD_Balance", "Balance:                 " + DoubleToStringCustom(balance,2), labelX, py, 10, txtMain); py += line;
    CreateOrUpdateLabel("BD_Equity",  "Equity:                    " + DoubleToStringCustom(equity,2), labelX, py, 10, txtMain); py += line;
    CreateOrUpdateLabel("BD_Float",   "Floating P/L:           " + DoubleToStringCustom(floating,2), labelX, py, 10, (floating >= 0 ? aquaNeon : redSoft)); py += line + 6;

    CreateOrUpdateLabel("BD_Margin", "Used Margin:          " + DoubleToStringCustom(margin,2), labelX, py, 10, txtMain); py += line;
    CreateOrUpdateLabel("BD_Free",   "Free Margin:           " + DoubleToStringCustom(freeMargin,2), labelX, py, 10, txtMain); py += line;
    CreateOrUpdateLabel("BD_Level",  "Margin Level:         "  + DoubleToStringCustom(marginLevel,2)+" %", labelX, py, 10, (marginLevel > 500 ? limeNeon : (marginLevel > 200 ? yellowSoft : redSoft))); py += line + 8;

    CreateOrUpdateLabel("BD_PToday",  StringFormat("Today's Profit:        %.2f", todayProfit), labelX, py, 10, (todayProfit >= 0 ? cyanSoft : redSoft)); py += line;
    CreateOrUpdateLabel("BD_PWeek",   StringFormat("Weekly Profit:         %.2f", weeklyProfit), labelX, py, 10, (weeklyProfit >= 0 ? cyanSoft : redSoft)); py += line;
    CreateOrUpdateLabel("BD_PMonth",  StringFormat("Monthly Profit:       %.2f", monthlyProfit), labelX, py, 10, (monthlyProfit >= 0 ? cyanSoft : redSoft)); py += line + 10;

    string strategyName  = OnlyManualTrading ? "MANUAL MODE" : (Use_Stoh == TRUE ? "Stochastic" : "Grid MA");
    string overlapStatus = EnableSafeOverlap ? "Overlap: ON" : "Overlap: OFF";

    CreateOrUpdateLabel("BD_Strategy",
        "Strategy:  " + strategyName + " | " + overlapStatus,
        labelX, py, 10, yellowSoft);
    py += line + 6;

    CreateOrUpdateLabel("BD_Header2", "Order        No.   Volume Amount", labelX, py, 10, yellowSoft); py += line;

    CreateOrUpdateLabel("BD_BUY",  StringFormat("BUY           %d     %.2f     $%.2f",  buyCount,  buyVolume,  buyProfit),  labelX, py, 10, (buyProfit >= 0 ? limeNeon : redSoft)); py += line;
    CreateOrUpdateLabel("BD_SELL", StringFormat("SELL          %d     %.2f     $%.2f", sellCount, sellVolume, sellProfit), labelX, py, 10, (sellProfit >= 0 ? limeNeon : redSoft)); py += line;
    CreateOrUpdateLabel("BD_TOTAL",StringFormat("TOTAL       %d     %.2f     $%.2f", totalCount,totalVolume,totalProfit), labelX, py, 10, (totalProfit >= 0 ? aquaNeon : redSoft));

    ChartRedraw();
}

double CalculateClosedProfit(datetime fromTime)
{
    double profit = 0;

    HistorySelect(fromTime, TimeCurrent());

    for (int i = HistoryDealsTotal() - 1; i >= 0; i--)
    {
        ulong  ticket     = HistoryDealGetTicket(i);
        string symbol     = HistoryDealGetString(ticket, DEAL_SYMBOL);
        long   dealMagic  = HistoryDealGetInteger(ticket, DEAL_MAGIC);

        if (ticket > 0 && HistoryDealGetInteger(ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
        {
            if (symbol == _Symbol && (OnlyManualTrading || dealMagic == Magic || (ManualHandOrder && dealMagic == 0)))
                profit += HistoryDealGetDouble(ticket, DEAL_PROFIT);
        }
    }

    return profit;
}

double CalculateTodayOpenProfit(datetime todayStart)
{
    double profit = 0;

    for (int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);

        if (ShouldManagePosition(ticket) && (datetime)PositionGetInteger(POSITION_TIME) >= todayStart)
            profit += PositionGetDouble(POSITION_PROFIT);
    }

    return profit;
}
//+------------------------------------------------------------------+
